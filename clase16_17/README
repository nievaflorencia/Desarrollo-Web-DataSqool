# Clase 16 - Desarrollando juegos avanzados con js

# Construir un juego espacial Parte 1: Introducción

En esta lección aprenderás a construir tu propio juego espacial. Si alguna vez has jugado al juego "Space Invaders", este juego tiene la misma idea: dirigir una nave espacial y disparar contra los monstruos que descienden desde arriba.

![video](../clase16_17/images/pewpew.gif)

En estas seis lecciones aprenderemos lo siguiente:

- Interactuar con el elemento Canvas para dibujar cosas en una pantalla
- Comprender el sistema de coordenadas cartesianas
- Aprenda el patrón Pub-Sub para crear una arquitectura de juego sólida que sea más fácil de mantener y ampliar
- Apalancamiento Asíncrono/Espera para cargar recursos del juego
- Controlar eventos de teclado

**Descripción general**

- Teoría
  - Introducción a la creación de juegos con JavaScript

- Práctica
  - Dibujar sobre lienzo
  - Mover elementos por la pantalla
  - Detección de colisiones
  - Manteniendo el marcador
  - Finalizar y reiniciar el juego.

## Introducción ##

### Herencia y composición en el desarrollo de juegos

En lecciones anteriores, no había mucha necesidad de preocuparse por la arquitectura de diseño de las aplicaciones que creó, ya que los proyectos tenían un alcance muy pequeño. Sin embargo, cuando sus aplicaciones crecen en tamaño y alcance, las decisiones arquitectónicas se vuelven una preocupación mayor. Hay dos enfoques principales para crear aplicaciones más grandes en JavaScript: *composición* o *herencia* . Ambos tienen pros y contras, pero vamos a explicarlos desde el contexto de un juego.

✅Uno de los libros de programación más famosos jamás escritos tiene que ver con [los patrones de diseño](https://en.wikipedia.org/wiki/Design_Patterns) .

En un juego tienes `game objects`que son objetos que existen en una pantalla. Esto significa que tienen una ubicación en un sistema de coordenadas cartesianas, caracterizado por tener una coordenada `x`y `y`. A medida que desarrolle un juego, notará que todos sus objetos de juego tienen una propiedad estándar, común para cada juego que crea, elementos que son:

- **basado en la ubicación**`xy`
  La mayoría de los elementos del juego, si no todos, se basan en la ubicación. Esto significa que tienen una ubicación, un `x` e `y`.
- **movible**
  Estos son objetos que pueden moverse a una nueva ubicación. Suele ser un héroe, un monstruo o un NPC (un personaje que no es jugador), pero no, por ejemplo, un objeto estático como un árbol.
- **autodestrucción**`deaddestroyed`
  Estos objetos solo existen durante un período de tiempo determinado antes de configurarse para su eliminación. Por lo general, esto se representa mediante un valor booleano `dead` o `destroyed` que indica al motor del juego que este objeto ya no debe representarse.
- **cool-down**
  `Cool-down` es una propiedad típica entre los objetos de vida corta. Un ejemplo típico es un texto o un efecto gráfico como una explosión que solo debería verse durante unos pocos milisegundos.

✅Piensa en un juego como Pac-Man. ¿Puedes identificar los cuatro tipos de objetos mencionados anteriormente en este juego?

### Expresando comportamiento

Todo lo que describimos anteriormente es el comportamiento que pueden tener los objetos del juego. Entonces, ¿cómo los codificamos? Podemos expresar este comportamiento como métodos asociados a clases u objetos.

**Clases**

La idea es usar `classes`en conjunto con `inheritance`para lograr agregar un cierto comportamiento a una clase.

✅La herencia es un concepto importante de entender. Obtén más información en [el artículo de MDN sobre la herencia](https://developer.mozilla.org/docs/Web/JavaScript/Inheritance_and_the_prototype_chain) .

Expresado a través de código, un objeto de juego normalmente puede tener este aspecto:

```javascript
//configurar la clase GameObject
class GameObject {
  constructor(x, y, type) {
    this.x = x;
    this.y = y;
    this.type = type;
  }
}

//esta clase ampliará las propiedades de clase inherentes del GameObject
class Movable extends GameObject {
  constructor(x,y, type) {
    super(x,y, type)
  }

//este objeto móvil se puede mover en la pantalla
  moveTo(x, y) {
    this.x = x;
    this.y = y;
  }
}

//esta es una clase específica que extiende la clase Movable, por lo que puede aprovechar todas las propiedades que hereda
class Hero extends Movable {
  constructor(x,y) {
    super(x,y, 'Hero')
  }
}

//esta clase, por otro lado, sólo hereda las propiedades de GameObject
class Tree extends GameObject {
  constructor(x,y) {
    super(x,y, 'Tree')
  }
}

//un héroe puede moverse..
const hero = new Hero();
hero.moveTo(5,5);

//pero un árbol no puede
const tree = new Tree();
```

✅Tómese unos minutos para volver a imaginar un héroe de Pac-Man (Inky, Pinky o Blinky, por ejemplo) y cómo se escribiría en JavaScript.

**Composición**

Una forma diferente de manejar la herencia de objetos es mediante el uso *de Composición* . Entonces, los objetos expresan su comportamiento así:

```javascript
//crear un objeto de gameObject
const gameObject = {
  x: 0,
  y: 0,
  type: ''
};

//...y un movimiento constante 
const movable = {
  moveTo(x, y) {
    this.x = x;
    this.y = y;
  }
}
//entonces la constante movableObject se compone de gameObject y constantes móviles
const movableObject = {...gameObject, ...movable};

//luego cree una función para crear un nuevo héroe que herede las propiedades de movableObject
function createHero(x, y) {
  return {
    ...movableObject,
    x,
    y,
    type: 'Hero'
  }
}
//... y un objeto estático que hereda sólo las propiedades de gameObject
function createStatic(x, y, type) {
  return {
    ...gameObject
    x,
    y,
    type
  }
}
//crea el héroe y muévelo
const hero = createHero(10,10);
hero.moveTo(5,5);
//and create a static tree which only stands around
const tree = createStatic(0,0, 'Tree');
```

**¿Qué patrón debo usar?**

Depende de ti qué patrón eliges. JavaScript admite ambos paradigmas.

Otro patrón común en el desarrollo de juegos aborda el problema de manejar la experiencia y el rendimiento del usuario del juego.

## Patrón de publicación/suscripción

✅Pub/Sub significa 'publicar-suscribir'

Este patrón aborda la idea de que las partes dispares de su aplicación no deberían conocerse entre sí. ¿Porqué es eso? Hace que sea mucho más fácil ver lo que sucede en general si se separan varias partes. También hace que sea más fácil cambiar repentinamente el comportamiento si es necesario. ¿Cómo logramos esto? Esto lo hacemos estableciendo algunos conceptos:

- **mensaje** 
  :un mensaje suele ser una cadena de texto acompañada de una carga útil opcional (un dato que aclara de qué se trata el mensaje). Un mensaje típico en un juego puede ser `KEY_PRESSED_ENTER`
  .
- **editor**
  : este elemento publica  un mensaje y lo envía a todos los suscriptores.
- **suscriptor**
  : este elemento escucha mensajes específicos y realiza alguna tarea como resultado de recibir este mensaje, como disparar un láser.

La implementación es bastante pequeña en tamaño pero es un patrón muy poderoso. Así es como se puede implementar:

```javascript
//configurar una clase EventEmitter que contenga oyentes
class EventEmitter {
  constructor() {
    this.listeners = {};
  }
//cuando se recibe un mensaje, deja que el oyente maneje su carga útil
  on(message, listener) {
    if (!this.listeners[message]) {
      this.listeners[message] = [];
    }
    this.listeners[message].push(listener);
  }
//cuando se envúa un mensaje, envíalo a un oyente con alguna carga útil
  emit(message, payload = null) {
    if (this.listeners[message]) {
      this.listeners[message].forEach(l => l(message, payload))
    }
  }
}
```

Para usar el código anterior, podemos crear una implementación muy pequeña:

```javascript
//configurar una estructura de mensaje
const Messages = {
  HERO_MOVE_LEFT: 'HERO_MOVE_LEFT'
};
//invoca el eventEmitter que configuraste anteriormente
const eventEmitter = new EventEmitter();
//establecer un héroe
const hero = createHero(0,0);
//informar al eventEmitter que esté atento a los mensajes relacionados con el héroe que se mueve hacia la izquierda y actúe en consecuencia.
eventEmitter.on(Messages.HERO_MOVE_LEFT, () => {
  hero.move(5,0);
});

//configure la ventana para escuchar el evento de tecla, específicamente si se presiona la flecha izquierda, emita un mensaje para mover al héroe hacia la izquierda
window.addEventListener('keyup', (evt) => {
  if (evt.key === 'ArrowLeft') {
    eventEmitter.emit(Messages.HERO_MOVE_LEFT)
  }
});
```

Arriba conectamos un evento de teclado `ArrowLeft`y enviamos el `HERO_MOVE_LEFT`mensaje. Escuchamos ese mensaje y lo movemos `hero`como resultado. El punto fuerte de este patrón es que el oyente del evento y el héroe no se conocen. Puede reasignar el `ArrowLeft`a la `A`clave. Además, sería posible hacer algo completamente diferente `ArrowLeft`haciendo algunas ediciones en la `on`función de eventEmitter:

```javascript
eventEmitter.on(Messages.HERO_MOVE_LEFT, () => {
  hero.move(5,0);
});
```

A medida que las cosas se vuelven más complicadas cuando tu juego crece, este patrón se mantiene igual en complejidad y tu código se mantiene limpio. Es muy recomendable adoptar este patrón.



# Construye un juego espacial, parte 2: dibuja héroes y monstruos en el lienzo

## Canva

Canva (lienzo) es un elemento HTML que por defecto no tiene contenido; es una pizarra en blanco. Necesitas agregarle dibujando sobre él.

✅Lea [más sobre la API de Canvas](https://developer.mozilla.org/docs/Web/API/Canvas_API) en MDN.

Así es como se declara normalmente, como parte del cuerpo de la página:

```HTML
<canvas id="myCanvas" width="200" height="100"></canvas>
```

Arriba estamos configurando `id`, `width`y `height`.

- `id`: configure esto para que pueda obtener una referencia cuando necesite interactuar con él.
    
- `width`: este es el ancho del elemento.
    
- `height`: esta es la altura del elemento.
    

## Dibujar geometría simple

El lienzo utiliza un sistema de coordenadas cartesianas para dibujar cosas. Por lo tanto, utiliza un eje x y un eje y para expresar dónde se encuentra algo. La ubicación `0,0`es la posición superior izquierda y la inferior derecha es lo que usted dijo que es el ANCHO y el ALTO del lienzo.

![Canvas](canvas_grid.png)


Para dibujar en el elemento del lienzo, deberá seguir los siguientes pasos:

1. **Obtenga una referencia** al elemento Canvas.
    
2. **Obtenga una referencia** sobre el elemento de contexto que se encuentra en el elemento de lienzo.
    
3. **Realice una operación de dibujo** utilizando el elemento de contexto.
    

El código para los pasos anteriores generalmente se ve así:

```Javascript
// Dibuja un rectángulo rojo
//1. Obtener la referencia de CANVAS
canvas = document.getElementById("myCanvas");

//2. Establezca el contexto en 2D para dibujar formas básicas
ctx = canvas.getContext("2d");

//3. Rellenalo con el color rojo
ctx.fillStyle = 'red';

//4. y dibuja un rectángulo con estos parámetros, configurando ubicación y tamaño
ctx.fillRect(0,0, 200, 200) // x,y,width, height
```

✅La API de Canvas se enfoca principalmente en formas 2D, pero también puede dibujar elementos 3D en un sitio web; para esto, puede usar la [API de WebGL](https://developer.mozilla.org/docs/Web/API/WebGL_API) .

Puede dibujar todo tipo de cosas con la API de Canvas como:

- **Formas geométricas** ya mostramos cómo dibujar un rectángulo, pero hay mucho más que puedes dibujar.
    
- **Texto** puede dibujar un texto con cualquier fuente y color que desee.
    
- **Imágenes**puede dibujar una imagen basada en un recurso de imagen como .jpg o .png, por ejemplo.
    

✅¡Intentalo! Sabes cómo dibujar un rectángulo, ¿puedes dibujar un círculo en una página? Eche un vistazo a algunos dibujos interesantes de Canvas en CodePen. He aquí un [ejemplo particularmente impresionante](https://codepen.io/dissimulate/pen/KrAwx) .

## Cargue y dibuje un recurso de imagen

Carga un activo de imagen creando un `Image`objeto y configurando su `src`propiedad. Luego, escucha el evento `load` para saber cuándo está listo para usarse. El código se ve así:

### Cargar activo

```javascript
const img = new Image();
img.src = 'path/to/my/image.png';
img.onload = () => {
  // Imagen cargada y lista para ser utilizada.
}
```

### Cargar patrón de activos

Se recomienda envolver lo anterior en una construcción como esta, para que sea más fácil de usar y solo intente manipularlo cuando esté completamente cargado:

```javascript
function loadAsset(path) {
  return new Promise((resolve) => {
    const img = new Image();
    img.src = path;
    img.onload = () => {
      // Imagen cargada y lista para ser utilizada.
      resolve(img);
    }
  })
}

// usar así

async function run() {
  const heroImg = await loadAsset('hero.png')
  const monsterImg = await loadAsset('monster.png')
}
```

Para dibujar activos del juego en una pantalla, su código se vería así:

```javascript
async function run() {
  const heroImg = await loadAsset('hero.png')
  const monsterImg = await loadAsset('monster.png')

  canvas = document.getElementById("myCanvas");
  ctx = canvas.getContext("2d");
  ctx.drawImage(heroImg, canvas.width/2,canvas.height/2);
  ctx.drawImage(monsterImg, 0,0);
}
```

## Ahora es el momento de comenzar a construir tu juego.

### que construir

Construirás una página web con un elemento Canvas. Debería mostrar una pantalla negra `1024*768`.Aqui tendrás dos imágenes:

- Nave héroe
    
    ![Nave héroe](../clase16_17/assets/player.png)
    
- 5*5 monstruo
    
    ![Nave Monstruo](../clase16_17/assets/enemyShip.png)
    

### Pasos recomendados para iniciar el desarrollo

Localice los archivos que se han creado para usted. Debe contener lo siguiente:

```bash
-| assets
  -| enemyShip.png
  -| player.png
-| index.html
-| app.js
-| package.json
```

Abra la copia de esta carpeta en Visual Studio Code. Debe tener una configuración de entorno de desarrollo local, preferiblemente con Visual Studio Code con NPM y Node instalados. Si no lo ha `npm`configurado en su computadora, [aquí le mostramos cómo hacerlo](https://www.npmjs.com/get-npm) .

Comience su proyecto navegando a la `juegoEspacial`carpeta:

```bash
cd juegoEspacial
npm start
```

Lo anterior iniciará un servidor HTTP en la dirección `http://localhost:5000`. Abre un navegador e ingresa esa dirección. Es una página en blanco en este momento, pero eso cambiará.

> Nota: para ver los cambios en su pantalla, actualice su navegador.
>

### Agregar código

Agregue el código necesario para `juegoEspacial/app.js`resolver lo siguiente

1. **Dibuja** un lienzo con fondo negro.
    
    > consejo: agregue en /app.js, configurando el elemento `ctx` para que sea negro y las coordenadas superior/izquierda estén en 0,0 y la altura y el ancho sean iguales a los de canva.
    > 
2. **Cargar** texturas
    
    > consejo: agregue las imágenes del jugador y del enemigo usando await loadTexturey pasando la ruta de la imagen. ¡Aún no los verás en la pantalla!
    > 
3. **Dibujar** héroe en el centro de la pantalla en la mitad inferior
    
    > consejo: use la drawImageAPI para dibujar hero Img en la pantalla, configurando canvas.width / 2 - 45y canvas.height - canvas.height / 4);
    > 
4. **Dibujar** 5*5 monstruos
    
    > consejo: ahora puedes descomentar el código para dibujar enemigos en la pantalla. A continuación, vaya a la createEnemiesfunción y constrúyala.
    > 
    
    Primero, configure algunas constantes:
    
    ```javascript
    const MONSTER_TOTAL = 5;
    const MONSTER_WIDTH = MONSTER_TOTAL * 98;
    const START_X = (canvas.width - MONSTER_WIDTH) / 2;
    const STOP_X = START_X + MONSTER_WIDTH;
    ```
    
    luego, crea un bucle para dibujar la matriz de monstruos en la pantalla:
    
    ```javascript
    for (let x = START_X; x < STOP_X; x += 98) {
        for (let y = 0; y < 50 * 5; y += 50) {
          ctx.drawImage(enemyImg, x, y);
        }
      }
    ```
    

## Resultado

El resultado final debería verse así:

![Ejemplo resultado primera parte](partI-solution.png)