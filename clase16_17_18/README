# Clase 16 - Desarrollando juegos avanzados con js

# Construir un juego espacial Parte 1: Introducci贸n

En esta lecci贸n aprender谩s a construir tu propio juego espacial. Si alguna vez has jugado al juego "Space Invaders", este juego tiene la misma idea: dirigir una nave espacial y disparar contra los monstruos que descienden desde arriba.

![video](../clase16_17/images/pewpew.gif)

En estas seis lecciones aprenderemos lo siguiente:

- Interactuar con el elemento Canvas para dibujar cosas en una pantalla
- Comprender el sistema de coordenadas cartesianas
- Aprenda el patr贸n Pub-Sub para crear una arquitectura de juego s贸lida que sea m谩s f谩cil de mantener y ampliar
- Apalancamiento As铆ncrono/Espera para cargar recursos del juego
- Controlar eventos de teclado

**Descripci贸n general**

- Teor铆a
  - Introducci贸n a la creaci贸n de juegos con JavaScript

- Pr谩ctica
  - Dibujar sobre lienzo
  - Mover elementos por la pantalla
  - Detecci贸n de colisiones
  - Manteniendo el marcador
  - Finalizar y reiniciar el juego.

## Introducci贸n ##

### Herencia y composici贸n en el desarrollo de juegos

En lecciones anteriores, no hab铆a mucha necesidad de preocuparse por la arquitectura de dise帽o de las aplicaciones que cre贸, ya que los proyectos ten铆an un alcance muy peque帽o.Sin embargo, cuando sus aplicaciones crecen en tama帽o y alcance, las decisiones arquitect贸nicas se vuelven una preocupaci贸n mayor.Hay dos enfoques principales para crear aplicaciones m谩s grandes en JavaScript:*composici贸n*o*herencia*.Ambos tienen pros y contras, pero vamos a explicarlos desde el contexto de un juego.

Uno de los libros de programaci贸n m谩s famosos jam谩s escritos tiene que ver con[los patrones de dise帽o](https://en.wikipedia.org/wiki/Design_Patterns).

En un juego tienes`game objects`que son objetos que existen en una pantalla.Esto significa que tienen una ubicaci贸n en un sistema de coordenadas cartesianas, caracterizado por tener una coordenada`x`y`y`.A medida que desarrolle un juego, notar谩 que todos sus objetos de juego tienen una propiedad est谩ndar, com煤n para cada juego que crea, elementos que son:

- **basado en la ubicaci贸n**`xy`
  La mayor铆a de los elementos del juego, si no todos, se basan en la ubicaci贸n.Esto significa que tienen una ubicaci贸n, un `x` e `y`.
- **movible**
  Estos son objetos que pueden moverse a una nueva ubicaci贸n.Suele ser un h茅roe, un monstruo o un NPC (un personaje que no es jugador), pero no, por ejemplo, un objeto est谩tico como un 谩rbol.
- **autodestrucci贸n**`deaddestroyed`
  Estos objetos solo existen durante un per铆odo de tiempo determinado antes de configurarse para su eliminaci贸n.Por lo general, esto se representa mediante un valor booleano `dead` o `destroyed` que indica al motor del juego que este objeto ya no debe representarse.
- **cool-down**
  `Cool-down` es una propiedad t铆pica entre los objetos de vida corta.Un ejemplo t铆pico es un texto o un efecto gr谩fico como una explosi贸n que solo deber铆a verse durante unos pocos milisegundos.

Piensa en un juego como Pac-Man.驴Puedes identificar los cuatro tipos de objetos mencionados anteriormente en este juego?

### Expresando comportamiento

Todo lo que describimos anteriormente es el comportamiento que pueden tener los objetos del juego.Entonces, 驴c贸mo los codificamos?Podemos expresar este comportamiento como m茅todos asociados a clases u objetos.

**Clases**

La idea es usar`classes`en conjunto con`inheritance`para lograr agregar un cierto comportamiento a una clase.

La herencia es un concepto importante de entender.Obt茅n m谩s informaci贸n en[el art铆culo de MDN sobre la herencia](https://developer.mozilla.org/docs/Web/JavaScript/Inheritance_and_the_prototype_chain).

Expresado a trav茅s de c贸digo, un objeto de juego normalmente puede tener este aspecto:

```javascript
//configurar la clase GameObject
class GameObject {
  constructor(x, y, type) {
    this.x = x;
    this.y = y;
    this.type = type;
  }
}

//esta clase ampliar谩 las propiedades de clase inherentes del GameObject
class Movable extends GameObject {
  constructor(x,y, type) {
    super(x,y, type)
  }

//este objeto m贸vil se puede mover en la pantalla
  moveTo(x, y) {
    this.x = x;
    this.y = y;
  }
}

//esta es una clase espec铆fica que extiende la clase Movable, por lo que puede aprovechar todas las propiedades que hereda
class Hero extends Movable {
  constructor(x,y) {
    super(x,y, 'Hero')
  }
}

//esta clase, por otro lado, s贸lo hereda las propiedades de GameObject
class Tree extends GameObject {
  constructor(x,y) {
    super(x,y, 'Tree')
  }
}

//un h茅roe puede moverse..
const hero = new Hero();
hero.moveTo(5,5);

//pero un 谩rbol no puede
const tree = new Tree();
```

T贸mese unos minutos para volver a imaginar un h茅roe de Pac-Man (Inky, Pinky o Blinky, por ejemplo) y c贸mo se escribir铆a en JavaScript.

**Composici贸n**

Una forma diferente de manejar la herencia de objetos es mediante el uso*de Composici贸n*.Entonces, los objetos expresan su comportamiento as铆:

```javascript
//crear un objeto de gameObject
const gameObject = {
  x: 0,
  y: 0,
  type: ''
};

//...y un movimiento constante 
const movable = {
  moveTo(x, y) {
    this.x = x;
    this.y = y;
  }
}
//entonces la constante movableObject se compone de gameObject y constantes m贸viles
const movableObject = {...gameObject, ...movable};

//luego cree una funci贸n para crear un nuevo h茅roe que herede las propiedades de movableObject
function createHero(x, y) {
  return {
    ...movableObject,
    x,
    y,
    type: 'Hero'
  }
}
//... y un objeto est谩tico que hereda s贸lo las propiedades de gameObject
function createStatic(x, y, type) {
  return {
    ...gameObject
    x,
    y,
    type
  }
}
//crea el h茅roe y mu茅velo
const hero = createHero(10,10);
hero.moveTo(5,5);
//and create a static tree which only stands around
const tree = createStatic(0,0, 'Tree');
```

**驴Qu茅 patr贸n debo usar?**

Depende de ti qu茅 patr贸n eliges.JavaScript admite ambos paradigmas.

Otro patr贸n com煤n en el desarrollo de juegos aborda el problema de manejar la experiencia y el rendimiento del usuario del juego.

## Patr贸n de publicaci贸n/suscripci贸n

Pub/Sub significa 'publicar-suscribir'

Este patr贸n aborda la idea de que las partes dispares de su aplicaci贸n no deber铆an conocerse entre s铆.驴Porqu茅 es eso?Hace que sea mucho m谩s f谩cil ver lo que sucede en general si se separan varias partes.Tambi茅n hace que sea m谩s f谩cil cambiar repentinamente el comportamiento si es necesario.驴C贸mo logramos esto?Esto lo hacemos estableciendo algunos conceptos:

- **mensaje** 
  :un mensaje suele ser una cadena de texto acompa帽ada de una carga 煤til opcional (un dato que aclara de qu茅 se trata el mensaje).Un mensaje t铆pico en un juego puede ser `KEY_PRESSED_ENTER`
  .
- **editor**
  : este elemento publica  un mensaje y lo env铆a a todos los suscriptores.
- **suscriptor**
  : este elemento escucha mensajes espec铆ficos y realiza alguna tarea como resultado de recibir este mensaje, como disparar un l谩ser.

La implementaci贸n es bastante peque帽a en tama帽o pero es un patr贸n muy poderoso.As铆 es como se puede implementar:

```javascript
//configurar una clase EventEmitter que contenga oyentes
class EventEmitter {
  constructor() {
    this.listeners = {};
  }
//cuando se recibe un mensaje, deja que el oyente maneje su carga 煤til
  on(message, listener) {
    if (!this.listeners[message]) {
      this.listeners[message] = [];
    }
    this.listeners[message].push(listener);
  }
//cuando se env煤a un mensaje, env铆alo a un oyente con alguna carga 煤til
  emit(message, payload = null) {
    if (this.listeners[message]) {
      this.listeners[message].forEach(l => l(message, payload))
    }
  }
}
```

Para usar el c贸digo anterior, podemos crear una implementaci贸n muy peque帽a:

```javascript
//configurar una estructura de mensaje
const Messages = {
  HERO_MOVE_LEFT: 'HERO_MOVE_LEFT'
};
//invoca el eventEmitter que configuraste anteriormente
const eventEmitter = new EventEmitter();
//establecer un h茅roe
const hero = createHero(0,0);
//informar al eventEmitter que est茅 atento a los mensajes relacionados con el h茅roe que se mueve hacia la izquierda y act煤e en consecuencia.
eventEmitter.on(Messages.HERO_MOVE_LEFT, () => {
  hero.move(5,0);
});

//configure la ventana para escuchar el evento de tecla, espec铆ficamente si se presiona la flecha izquierda, emita un mensaje para mover al h茅roe hacia la izquierda
window.addEventListener('keyup', (evt) => {
  if (evt.key === 'ArrowLeft') {
    eventEmitter.emit(Messages.HERO_MOVE_LEFT)
  }
});
```

Arriba conectamos un evento de teclado`ArrowLeft`y enviamos el`HERO_MOVE_LEFT`mensaje.Escuchamos ese mensaje y lo movemos`hero`como resultado.El punto fuerte de este patr贸n es que el oyente del evento y el h茅roe no se conocen.Puede reasignar el`ArrowLeft`a la`A`clave.Adem谩s, ser铆a posible hacer algo completamente diferente`ArrowLeft`haciendo algunas ediciones en la`on`funci贸n de eventEmitter:

```javascript
eventEmitter.on(Messages.HERO_MOVE_LEFT, () => {
  hero.move(5,0);
});
```

A medida que las cosas se vuelven m谩s complicadas cuando tu juego crece, este patr贸n se mantiene igual en complejidad y tu c贸digo se mantiene limpio.Es muy recomendable adoptar este patr贸n.



# Construye un juego espacial, parte 2: dibuja h茅roes y monstruos en el lienzo

## Canva

Canva (lienzo) es un elemento HTML que por defecto no tiene contenido;es una pizarra en blanco.Necesitas agregarle dibujando sobre 茅l.

Lea[m谩s sobre la API de Canvas](https://developer.mozilla.org/docs/Web/API/Canvas_API)en MDN.

As铆 es como se declara normalmente, como parte del cuerpo de la p谩gina:

```HTML
<canvas id="myCanvas" width="200" height="100"></canvas>
```

Arriba estamos configurando`id`,`width`y`height`.

- `id`: configure esto para que pueda obtener una referencia cuando necesite interactuar con 茅l.
    
- `width`: este es el ancho del elemento.
    
- `height`: esta es la altura del elemento.
    

## Dibujar geometr铆a simple

El lienzo utiliza un sistema de coordenadas cartesianas para dibujar cosas.Por lo tanto, utiliza un eje x y un eje y para expresar d贸nde se encuentra algo.La ubicaci贸n`0,0`es la posici贸n superior izquierda y la inferior derecha es lo que usted dijo que es el ANCHO y el ALTO del lienzo.

![Canvas](canvas_grid.png)


Para dibujar en el elemento del lienzo, deber谩 seguir los siguientes pasos:

1. **Obtenga una referencia** al elemento Canvas.
    
2. **Obtenga una referencia** sobre el elemento de contexto que se encuentra en el elemento de lienzo.
    
3. **Realice una operaci贸n de dibujo** utilizando el elemento de contexto.
    

El c贸digo para los pasos anteriores generalmente se ve as铆:

```Javascript
// Dibuja un rect谩ngulo rojo
//1. Obtener la referencia de CANVAS
canvas = document.getElementById("myCanvas");

//2. Establezca el contexto en 2D para dibujar formas b谩sicas
ctx = canvas.getContext("2d");

//3. Rellenalo con el color rojo
ctx.fillStyle = 'red';

//4. y dibuja un rect谩ngulo con estos par谩metros, configurando ubicaci贸n y tama帽o
ctx.fillRect(0,0, 200, 200) // x,y,width, height
```

La API de Canvas se enfoca principalmente en formas 2D, pero tambi茅n puede dibujar elementos 3D en un sitio web;para esto, puede usar la[API de WebGL](https://developer.mozilla.org/docs/Web/API/WebGL_API).

Puede dibujar todo tipo de cosas con la API de Canvas como:

- **Formas geom茅tricas** ya mostramos c贸mo dibujar un rect谩ngulo, pero hay mucho m谩s que puedes dibujar.
    
- **Texto** puede dibujar un texto con cualquier fuente y color que desee.
    
- **Im谩genes**puede dibujar una imagen basada en un recurso de imagen como .jpg o .png, por ejemplo.
    

隆Intentalo!Sabes c贸mo dibujar un rect谩ngulo, 驴puedes dibujar un c铆rculo en una p谩gina?Eche un vistazo a algunos dibujos interesantes de Canvas en CodePen.He aqu铆 un[ejemplo particularmente impresionante](https://codepen.io/dissimulate/pen/KrAwx).

## Cargue y dibuje un recurso de imagen

Carga un activo de imagen creando un`Image`objeto y configurando su`src`propiedad.Luego, escucha elevento `load` para saber cu谩ndo est谩 listo para usarse.El c贸digo se ve as铆:

### Cargar activo

```javascript
const img = new Image();
img.src = 'path/to/my/image.png';
img.onload = () => {
  // Imagen cargada y lista para ser utilizada.
}
```

### Cargar patr贸n de activos

Se recomienda envolver lo anterior en una construcci贸n como esta, para que sea m谩s f谩cil de usar y solo intente manipularlo cuando est茅 completamente cargado:

```javascript
function loadAsset(path) {
  return new Promise((resolve) => {
    const img = new Image();
    img.src = path;
    img.onload = () => {
      // Imagen cargada y lista para ser utilizada.
      resolve(img);
    }
  })
}

// usar as铆

async function run() {
  const heroImg = await loadAsset('hero.png')
  const monsterImg = await loadAsset('monster.png')
}
```

Para dibujar activos del juego en una pantalla, su c贸digo se ver铆a as铆:

```javascript
async function run() {
  const heroImg = await loadAsset('hero.png')
  const monsterImg = await loadAsset('monster.png')

  canvas = document.getElementById("myCanvas");
  ctx = canvas.getContext("2d");
  ctx.drawImage(heroImg, canvas.width/2,canvas.height/2);
  ctx.drawImage(monsterImg, 0,0);
}
```

## Ahora es el momento de comenzar a construir tu juego.

### que construir

Construir谩s una p谩gina web con un elemento Canvas.Deber铆a mostrar una pantalla negra`1024*768`.Aqui tendr谩s dos im谩genes:

- Nave h茅roe
    
    ![Nave h茅roe](../clase16_17_18/assets/player.png)
    
- 5*5 monstruo
    
    ![Nave Monstruo](../clase16_17_18/assets/enemyShip.png)
    

### Pasos recomendados para iniciar el desarrollo

Localice los archivos que se han creado para usted.Debe contener lo siguiente:

```bash
-| assets
  -| enemyShip.png
  -| player.png
-| index.html
-| app.js
-| package.json
```

Abra la copia de esta carpeta en Visual Studio Code.Debe tener una configuraci贸n de entorno de desarrollo local, preferiblemente con Visual Studio Code con NPM y Node instalados.Si no lo ha`npm`configurado en su computadora,[aqu铆 le mostramos c贸mo hacerlo](https://www.npmjs.com/get-npm).

Comience su proyecto navegando a lacarpeta`clase16_17_18`carpeta:

```bash
cd clase16_17_18
npm start
```

Lo anterior iniciar谩 un servidor HTTP en la direcci贸n`http://localhost:5000`.Abre un navegador e ingresa esa direcci贸n.Es una p谩gina en blanco en este momento, pero eso cambiar谩.

> Nota: para ver los cambios en su pantalla, actualice su navegador.
>

### Agregar c贸digo

Agregue el c贸digo necesario para`clase16_17_18/app.js`resolver lo siguiente

1. **Dibuja**un lienzo con fondo negro.
    
    > consejo: agregue en/app.js, configurando el elemento`ctx` para que sea negro y las coordenadas superior/izquierda est茅n en 0,0 y la altura y el ancho sean iguales a los de canva.
    > 
2. **Cargar**texturas
    
    > consejo: agregue las im谩genes del jugador y del enemigo usandoawait loadTexturey pasando la ruta de la imagen.隆A煤n no los ver谩s en la pantalla!
    > 
3. **Dibujar**h茅roe en el centro de la pantalla en la mitad inferior
    
    > consejo: use ladrawImageAPI para dibujar hero Img en la pantalla, configurandocanvas.width / 2 - 45ycanvas.height - canvas.height / 4);
    > 
4. **Dibujar**5*5 monstruos
    
    > consejo: ahora puedes descomentar el c贸digo para dibujar enemigos en la pantalla.A continuaci贸n, vaya a lacreateEnemiesfunci贸n y constr煤yala.
    > 
    
    Primero, configure algunas constantes:
    
    ```javascript
    const MONSTER_TOTAL = 5;
    const MONSTER_WIDTH = MONSTER_TOTAL * 98;
    const START_X = (canvas.width - MONSTER_WIDTH) / 2;
    const STOP_X = START_X + MONSTER_WIDTH;
    ```
    
    luego, crea un bucle para dibujar la matriz de monstruos en la pantalla:
    
    ```javascript
    for (let x = START_X; x < STOP_X; x += 98) {
        for (let y = 0; y < 50 * 5; y += 50) {
          ctx.drawImage(enemyImg, x, y);
        }
      }
    ```
    

## Resultado

El resultado final deber铆a verse as铆:

![Ejemplo resultado primera parte](partI-solution.png)

# Construir un juego espacial Parte 3: agregar movimiento

隆Los juegos no son muy divertidos hasta que tienes extraterrestres corriendo en la pantalla!En este juego, haremos uso de dos tipos de movimientos:

- **Movimiento de teclado/rat贸n**
    
    : cuando el usuario interact煤a con el teclado o el rat贸n para mover un objeto en la pantalla.
    
- **Movimiento inducido por el juego**
    
    : cuando el juego mueve un objeto con un cierto intervalo de tiempo.
    

Entonces, 驴c贸mo movemos las cosas en una pantalla?Se trata de coordenadas cartesianas: cambiamos la ubicaci贸n (x, y) del objeto y luego volvemos a dibujar la pantalla.

Por lo general, necesita los siguientes pasos para realizar*el movimiento*en una pantalla:

1. **Establecer una nueva ubicaci贸n**
    
    para un objeto;esto es necesario para percibir que el objeto se ha movido.
    
2. **Borrar la pantalla**
    
    , la pantalla debe limpiarse entre cada juego.Podemos despejarlo dibujando un rect谩ngulo que rellenamos con un color de fondo.
    
3. **Vuelva a dibujar el objeto**
    
    en la nueva ubicaci贸n.Al hacer esto, finalmente logramos mover el objeto de un lugar a otro.
    

As铆 es como puede verse en el c贸digo:

```javascript
//establecer la ubicaci贸n del h茅roe
hero.x += 5;
// Limpia el rect谩ngulo que alberga al h茅roe.
ctx.clearRect(0, 0, canvas.width, canvas.height);
// volver a dibujar el fondo y el h茅roe del juego
ctx.fillRect(0, 0, canvas.width, canvas.height)
ctx.fillStyle = "black";
ctx.drawImage(heroImg, hero.x, hero.y);
```

驴Puedes pensar en una raz贸n por la que volver a dibujar a tu h茅roe muchos fotogramas por segundo podr铆a generar costos de rendimiento?Lea acerca de[las alternativas a este patr贸n](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Optimizing_canvas).

## Manejar eventos de teclado

Maneja eventos adjuntando eventos espec铆ficos al c贸digo.Los eventos del teclado se activan en toda la ventana, mientras que los eventos del mouse, como un,`click`se pueden conectar al hacer clic en un elemento espec铆fico.Usaremos eventos de teclado a lo largo de este proyecto.

Para manejar un evento, debe usar elm茅todo `addEventListener()` y proporcionarle dos par谩metros de entrada.El primer par谩metro es el nombre del evento, por ejemplo`keyup`.El segundo par谩metro es la funci贸n que se debe invocar como resultado de que se produzca el evento.

Aqu铆 hay un ejemplo:

```JavaScript
window.addEventListener('keyup', (evt) => {
  // `evt.key` = representaci贸n de cadena de la clave
  if (evt.key === 'ArrowUp') {
    // hacer algo
  }
})
```

Para eventos clave, hay dos propiedades en el evento que puede usar para ver qu茅 tecla se presion贸:

- `key`
    
    , esta es una representaci贸n de cadena de la tecla presionada, por ejemplo `ArrowUp`
    
- `keyCode`
    
    , esta es una representaci贸n num茅rica, por ejemplo 37, corresponde a `ArrowLeft`.
    

La manipulaci贸n de eventos clave es 煤til fuera del desarrollo de juegos.驴Qu茅 otros usos se te ocurren para esta t茅cnica?

### Teclas especiales: una advertencia

Hay algunas teclas*especiales*que afectan a la ventana.Eso significa que si est谩s escuchando un`keyup`evento y usas estas teclas especiales para mover a tu h茅roe, tambi茅n realizar谩 el desplazamiento horizontal.Por esa raz贸n, es posible que desee*desactivar*este comportamiento integrado del navegador a medida que desarrolla su juego.Necesitas un c贸digo como este:

```JavaScript
let onKeyDown = function (e) {
  console.log(e.keyCode);
  switch (e.keyCode) {
    case 37:
    case 39:
    case 38:
    case 40: // Teclas de flechas
    case 32: // Tecla espacio
      e.preventDefault();
      break; 
    default:
      break; // No bloquear otras claves
  }
};

window.addEventListener('keydown', onKeyDown);
```
 m谩s info sobre el objeto window
- [window](https://developer.mozilla.org/es/docs/Web/API/Window)

El c贸digo anterior garantizar谩 que las teclas de flecha y la tecla de espacio tengan su comportamiento*predeterminado*desactivado.El mecanismo*de apagado*ocurre cuando llamamos`e.preventDefault()`.

## Movimiento inducido por el juego

Podemos hacer que las cosas se muevan solas usando temporizadores como la funci贸n`setTimeout()`o`setInterval()`que actualiza la ubicaci贸n del objeto en cada marca o intervalo de tiempo.Esto es lo que puede parecer:

```JavaScript
let id = setInterval(() => {
  // Mueve al enemigo en el eje y
  enemy.y += 10;
})
```

## el bucle del juego

El bucle del juego es un concepto que es esencialmente una funci贸n que se invoca a intervalos regulares.Se llama bucle de juego porque todo lo que deber铆a ser visible para el usuario se dibuja en el bucle.El bucle del juego hace uso de todos los objetos del juego que forman parte del juego, dibuj谩ndolos todos a menos que por alguna raz贸n ya no deban ser parte del juego.Por ejemplo, si un objeto es un enemigo que fue golpeado por un l谩ser y explota, ya no forma parte del ciclo actual del juego (aprender谩s m谩s sobre esto en lecciones posteriores).

Este es el aspecto t铆pico de un bucle de juego, expresado en c贸digo:

```JavaScript
let gameLoopId = setInterval(() =>
  function gameLoop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    drawHero();
    drawEnemies();
    drawStaticObjects();
}, 200);
```

El bucle anterior se invoca cada`200`milisegundos para volver a dibujar el lienzo.Tienes la posibilidad de elegir el mejor intervalo que tenga sentido para tu juego.

## Continuando con el juego espacial

Tomar谩 el c贸digo existente y lo ampliar谩.Comienza con el c贸digo que completaste durante la parte I o usa el c贸digo enla segunda parte.

- **Mover al h茅roe**
    
    : agregar谩 c贸digo para asegurarse de que puede mover al h茅roe con las teclas de flecha.
    
- **Mover enemigos**
    
    : tambi茅n deber谩 agregar c贸digo para asegurarse de que los enemigos se muevan de arriba a abajo a un ritmo determinado.
    

## Pasos recomendados

Localice los archivos que se han creado para usted .Debe contener lo siguiente:

```bash
-| assets
  -| enemyShip.png
  -| player.png
-| index.html
-| app.js
-| package.json
```

Inicia su proyecto en lacarpeta escribiendo:

```bash
cd clase16_17_18
npm start
```

Lo anterior iniciar谩 un servidor HTTP en la direcci贸n`http://localhost:5000`.Abra un navegador e ingrese esa direcci贸n, en este momento deber铆a representar al h茅roe y a todos los enemigos;nada se mueve, 隆todav铆a!

### Agregar c贸digo

1. **Agregue objetos dedicados**para`hero`and`enemy`y`game object`, deben tener propiedades`x`y`y`.(Recordar la parte sobreHerencia o composici贸n.
    
    *SUGERENCIA*`game object`debe ser el que tiene`x`y`y`la capacidad de dibujarse a s铆 mismo en un lienzo.
    
    > consejo: comience agregando una nueva clase GameObject con su constructor delineado como se muestra a continuaci贸n, y luego dib煤jelo en el lienzo:
    > 
    
    ```JavaScript
    class GameObject {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.dead = false;
        this.type = "";
        this.width = 0;
        this.height = 0;
        this.img = undefined;
      }
    
      draw(ctx) {
        ctx.drawImage(this.img, this.x, this.y, this.width, this.height);
      }
    }
    ```
    
    Ahora, extienda este GameObject para crear el H茅roe y el Enemigo.
    
    ```JavaScript
    class Hero extends GameObject {
      constructor(x, y) {
        ...it needs an x, y, type, and speed
      }
    }
    ```
    
    ```JavaScript
    class Enemy extends GameObject {
      constructor(x, y) {
        super(x, y);
        (this.width = 98), (this.height = 50);
        this.type = "Enemy";
        let id = setInterval(() => {
          if (this.y < canvas.height - this.height) {
            this.y += 5;
          } else {
            console.log('Stopped at', this.y)
            clearInterval(id);
          }
        }, 300)
      }
    }
    ```
    
2. **Agregue controladores de eventos clave**para manejar la navegaci贸n clave (mover h茅roe arriba/abajo izquierda/derecha)
    
    *RECUERDE*que es un sistema cartesiano, arriba a la izquierda es`0,0`.Tambi茅n recuerde agregar c贸digo para detener*el comportamiento predeterminado*
    
    > consejo: cree su funci贸n onKeyDown y adj煤ntela a la ventana:
    > 
    
    ```JavaScript
     let onKeyDown = function (e) {
           console.log(e.keyCode);
             ...agregue el c贸digo de la lecci贸n anterior para detener
             default behavior
           }
     };
    
     window.addEventListener("keydown", onKeyDown);
    ```
    
    Verifique la consola de su navegador en este punto y observe c贸mo se registran las pulsaciones de teclas.
    
3. **Implemente**elpatr贸n Pub/sub, esto mantendr谩 su c贸digo limpio mientras sigue las partes restantes.
    
    Para hacer esta 煤ltima parte, puedes:
    
    1. **Agregue un detector de eventos**en la ventana:
        
        ```JavaScript
         window.addEventListener("keyup", (evt) => {
           if (evt.key === "ArrowUp") {
             eventEmitter.emit(Messages.KEY_EVENT_UP);
           } else if (evt.key === "ArrowDown") {
             eventEmitter.emit(Messages.KEY_EVENT_DOWN);
           } else if (evt.key === "ArrowLeft") {
             eventEmitter.emit(Messages.KEY_EVENT_LEFT);
           } else if (evt.key === "ArrowRight") {
             eventEmitter.emit(Messages.KEY_EVENT_RIGHT);
           }
         });
        ```
        
    2. **Crea una clase EventEmitter**para publicar y suscribirte a los mensajes:
        
        ```JavaScript
        class EventEmitter {
          constructor() {
            this.listeners = {};
          }
        
          on(message, listener) {
            if (!this.listeners[message]) {
              this.listeners[message] = [];
            }
            this.listeners[message].push(listener);
          }
        
          emit(message, payload = null) {
            if (this.listeners[message]) {
              this.listeners[message].forEach((l) => l(message, payload));
            }
          }
        }
        ```
        
    3. **Agregue constantes**y configure EventEmitter:
        
        ```JavaScript
        const Messages = {
          KEY_EVENT_UP: "KEY_EVENT_UP",
          KEY_EVENT_DOWN: "KEY_EVENT_DOWN",
          KEY_EVENT_LEFT: "KEY_EVENT_LEFT",
          KEY_EVENT_RIGHT: "KEY_EVENT_RIGHT",
        };
        
        let heroImg,
            enemyImg,
            laserImg,
            canvas, ctx,
            gameObjects = [],
            hero,
            eventEmitter = new EventEmitter();
        ```
        
    4. **Inicializar el juego**
    
    ```JavaScript
    function initGame() {
      gameObjects = [];
      createEnemies();
      createHero();
    
      eventEmitter.on(Messages.KEY_EVENT_UP, () => {
        hero.y -=5 ;
      })
    
      eventEmitter.on(Messages.KEY_EVENT_DOWN, () => {
        hero.y += 5;
      });
    
      eventEmitter.on(Messages.KEY_EVENT_LEFT, () => {
        hero.x -= 5;
      });
    
      eventEmitter.on(Messages.KEY_EVENT_RIGHT, () => {
        hero.x += 5;
      });
    }
    ```
    
4. **Configurar el bucle del juego**
    
    Refactorice la funci贸n window.onload para inicializar el juego y configurar un bucle de juego en un buen intervalo.Tambi茅n agregar谩 un rayo l谩ser:
    
    ```JavaScript
    window.onload = async () => {
      canvas = document.getElementById("canvas");
      ctx = canvas.getContext("2d");
      heroImg = await loadTexture("assets/player.png");
      enemyImg = await loadTexture("assets/enemyShip.png");
      laserImg = await loadTexture("assets/laserRed.png");
    
      initGame();
      let gameLoopId = setInterval(() => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        drawGameObjects(ctx);
      }, 100)
    
    };
    ```
    
5. **Agregue c贸digo**para mover enemigos en un cierto intervalo
    
    Refactorice la`createEnemies()`funci贸n para crear los enemigos e introd煤zcalos en la nueva clase gameObjects:
    
    ```JavaScript
    function createEnemies() {
      const MONSTER_TOTAL = 5;
      const MONSTER_WIDTH = MONSTER_TOTAL * 98;
      const START_X = (canvas.width - MONSTER_WIDTH) / 2;
      const STOP_X = START_X + MONSTER_WIDTH;
    
      for (let x = START_X; x < STOP_X; x += 98) {
        for (let y = 0; y < 50 * 5; y += 50) {
          const enemy = new Enemy(x, y);
          enemy.img = enemyImg;
          gameObjects.push(enemy);
        }
      }
    }
    ```
    
    y agregue una`createHero()`funci贸n para hacer un proceso similar para el h茅roe.
    
    ```JavaScript
    function createHero() {
      hero = new Hero(
        canvas.width / 2 - 45,
        canvas.height - canvas.height / 4
      );
      hero.img = heroImg;
      gameObjects.push(hero);
    }
    ```
    
    y finalmente, agregue una`drawGameObjects()`funci贸n para comenzar el dibujo:
    
    ```JavaScript
    function drawGameObjects(ctx) {
      gameObjects.forEach(go => go.draw(ctx));
    }
    ```
    
    隆Tus enemigos deber铆an comenzar a avanzar en tu nave espacial heroica!


