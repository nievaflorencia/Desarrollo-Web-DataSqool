# Clase 16 - Desarrollando juegos avanzados con js

# Construir un juego espacial Parte 1: Introducción

En esta lección aprenderás a construir tu propio juego espacial. Si alguna vez has jugado al juego "Space Invaders", este juego tiene la misma idea: dirigir una nave espacial y disparar contra los monstruos que descienden desde arriba.

![video](../clase16_17/images/pewpew.gif)

En estas seis lecciones aprenderemos lo siguiente:

- Interactuar con el elemento Canvas para dibujar cosas en una pantalla
- Comprender el sistema de coordenadas cartesianas
- Aprenda el patrón Pub-Sub para crear una arquitectura de juego sólida que sea más fácil de mantener y ampliar
- Apalancamiento Asíncrono/Espera para cargar recursos del juego
- Controlar eventos de teclado

**Descripción general**

- Teoría
  - Introducción a la creación de juegos con JavaScript

- Práctica
  - Dibujar sobre lienzo
  - Mover elementos por la pantalla
  - Detección de colisiones
  - Manteniendo el marcador
  - Finalizar y reiniciar el juego.

## Introducción ##

### Herencia y composición en el desarrollo de juegos

En lecciones anteriores, no había mucha necesidad de preocuparse por la arquitectura de diseño de las aplicaciones que creó, ya que los proyectos tenían un alcance muy pequeño. Sin embargo, cuando sus aplicaciones crecen en tamaño y alcance, las decisiones arquitectónicas se vuelven una preocupación mayor. Hay dos enfoques principales para crear aplicaciones más grandes en JavaScript: *composición* o *herencia* . Ambos tienen pros y contras, pero vamos a explicarlos desde el contexto de un juego.

✅Uno de los libros de programación más famosos jamás escritos tiene que ver con [los patrones de diseño](https://en.wikipedia.org/wiki/Design_Patterns) .

En un juego tienes `game objects`que son objetos que existen en una pantalla. Esto significa que tienen una ubicación en un sistema de coordenadas cartesianas, caracterizado por tener una coordenada `x`y `y`. A medida que desarrolle un juego, notará que todos sus objetos de juego tienen una propiedad estándar, común para cada juego que crea, elementos que son:

- **basado en la ubicación**`xy`
  La mayoría de los elementos del juego, si no todos, se basan en la ubicación. Esto significa que tienen una ubicación, un `x` e `y`.
- **movible**
  Estos son objetos que pueden moverse a una nueva ubicación. Suele ser un héroe, un monstruo o un NPC (un personaje que no es jugador), pero no, por ejemplo, un objeto estático como un árbol.
- **autodestrucción**`deaddestroyed`
  Estos objetos solo existen durante un período de tiempo determinado antes de configurarse para su eliminación. Por lo general, esto se representa mediante un valor booleano `dead` o `destroyed` que indica al motor del juego que este objeto ya no debe representarse.
- **cool-down**
  `Cool-down` es una propiedad típica entre los objetos de vida corta. Un ejemplo típico es un texto o un efecto gráfico como una explosión que solo debería verse durante unos pocos milisegundos.

✅Piensa en un juego como Pac-Man. ¿Puedes identificar los cuatro tipos de objetos mencionados anteriormente en este juego?

### Expresando comportamiento

Todo lo que describimos anteriormente es el comportamiento que pueden tener los objetos del juego. Entonces, ¿cómo los codificamos? Podemos expresar este comportamiento como métodos asociados a clases u objetos.

**Clases**

La idea es usar `classes`en conjunto con `inheritance`para lograr agregar un cierto comportamiento a una clase.

✅La herencia es un concepto importante de entender. Obtén más información en [el artículo de MDN sobre la herencia](https://developer.mozilla.org/docs/Web/JavaScript/Inheritance_and_the_prototype_chain) .

Expresado a través de código, un objeto de juego normalmente puede tener este aspecto:

```javascript
//configurar la clase GameObject
class GameObject {
  constructor(x, y, type) {
    this.x = x;
    this.y = y;
    this.type = type;
  }
}

//esta clase ampliará las propiedades de clase inherentes del GameObject
class Movable extends GameObject {
  constructor(x,y, type) {
    super(x,y, type)
  }

//este objeto móvil se puede mover en la pantalla
  moveTo(x, y) {
    this.x = x;
    this.y = y;
  }
}

//esta es una clase específica que extiende la clase Movable, por lo que puede aprovechar todas las propiedades que hereda
class Hero extends Movable {
  constructor(x,y) {
    super(x,y, 'Hero')
  }
}

//esta clase, por otro lado, sólo hereda las propiedades de GameObject
class Tree extends GameObject {
  constructor(x,y) {
    super(x,y, 'Tree')
  }
}

//un héroe puede moverse..
const hero = new Hero();
hero.moveTo(5,5);

//pero un árbol no puede
const tree = new Tree();
```

✅Tómese unos minutos para volver a imaginar un héroe de Pac-Man (Inky, Pinky o Blinky, por ejemplo) y cómo se escribiría en JavaScript.

**Composición**

Una forma diferente de manejar la herencia de objetos es mediante el uso *de Composición* . Entonces, los objetos expresan su comportamiento así:

```javascript
//crear un objeto de gameObject
const gameObject = {
  x: 0,
  y: 0,
  type: ''
};

//...y un movimiento constante 
const movable = {
  moveTo(x, y) {
    this.x = x;
    this.y = y;
  }
}
//entonces la constante movableObject se compone de gameObject y constantes móviles
const movableObject = {...gameObject, ...movable};

//luego cree una función para crear un nuevo héroe que herede las propiedades de movableObject
function createHero(x, y) {
  return {
    ...movableObject,
    x,
    y,
    type: 'Hero'
  }
}
//... y un objeto estático que hereda sólo las propiedades de gameObject
function createStatic(x, y, type) {
  return {
    ...gameObject
    x,
    y,
    type
  }
}
//crea el héroe y muévelo
const hero = createHero(10,10);
hero.moveTo(5,5);
//and create a static tree which only stands around
const tree = createStatic(0,0, 'Tree');
```

**¿Qué patrón debo usar?**

Depende de ti qué patrón eliges. JavaScript admite ambos paradigmas.

Otro patrón común en el desarrollo de juegos aborda el problema de manejar la experiencia y el rendimiento del usuario del juego.

## Patrón de publicación/suscripción

✅Pub/Sub significa 'publicar-suscribir'

Este patrón aborda la idea de que las partes dispares de su aplicación no deberían conocerse entre sí. ¿Porqué es eso? Hace que sea mucho más fácil ver lo que sucede en general si se separan varias partes. También hace que sea más fácil cambiar repentinamente el comportamiento si es necesario. ¿Cómo logramos esto? Esto lo hacemos estableciendo algunos conceptos:

- **mensaje** 
  :un mensaje suele ser una cadena de texto acompañada de una carga útil opcional (un dato que aclara de qué se trata el mensaje). Un mensaje típico en un juego puede ser `KEY_PRESSED_ENTER`
  .
- **editor**
  : este elemento publica  un mensaje y lo envía a todos los suscriptores.
- **suscriptor**
  : este elemento escucha mensajes específicos y realiza alguna tarea como resultado de recibir este mensaje, como disparar un láser.

La implementación es bastante pequeña en tamaño pero es un patrón muy poderoso. Así es como se puede implementar:

```javascript
//configurar una clase EventEmitter que contenga oyentes
class EventEmitter {
  constructor() {
    this.listeners = {};
  }
//cuando se recibe un mensaje, deja que el oyente maneje su carga útil
  on(message, listener) {
    if (!this.listeners[message]) {
      this.listeners[message] = [];
    }
    this.listeners[message].push(listener);
  }
//cuando se envúa un mensaje, envíalo a un oyente con alguna carga útil
  emit(message, payload = null) {
    if (this.listeners[message]) {
      this.listeners[message].forEach(l => l(message, payload))
    }
  }
}
```

Para usar el código anterior, podemos crear una implementación muy pequeña:

```javascript
//configurar una estructura de mensaje
const Messages = {
  HERO_MOVE_LEFT: 'HERO_MOVE_LEFT'
};
//invoca el eventEmitter que configuraste anteriormente
const eventEmitter = new EventEmitter();
//establecer un héroe
const hero = createHero(0,0);
//informar al eventEmitter que esté atento a los mensajes relacionados con el héroe que se mueve hacia la izquierda y actúe en consecuencia.
eventEmitter.on(Messages.HERO_MOVE_LEFT, () => {
  hero.move(5,0);
});

//configure la ventana para escuchar el evento de tecla, específicamente si se presiona la flecha izquierda, emita un mensaje para mover al héroe hacia la izquierda
window.addEventListener('keyup', (evt) => {
  if (evt.key === 'ArrowLeft') {
    eventEmitter.emit(Messages.HERO_MOVE_LEFT)
  }
});
```

Arriba conectamos un evento de teclado `ArrowLeft`y enviamos el `HERO_MOVE_LEFT`mensaje. Escuchamos ese mensaje y lo movemos `hero`como resultado. El punto fuerte de este patrón es que el oyente del evento y el héroe no se conocen. Puede reasignar el `ArrowLeft`a la `A`clave. Además, sería posible hacer algo completamente diferente `ArrowLeft`haciendo algunas ediciones en la `on`función de eventEmitter:

```javascript
eventEmitter.on(Messages.HERO_MOVE_LEFT, () => {
  hero.move(5,0);
});
```

A medida que las cosas se vuelven más complicadas cuando tu juego crece, este patrón se mantiene igual en complejidad y tu código se mantiene limpio. Es muy recomendable adoptar este patrón.



# Construye un juego espacial, parte 2: dibuja héroes y monstruos en el lienzo

## Canva

Canva (lienzo) es un elemento HTML que por defecto no tiene contenido; es una pizarra en blanco. Necesitas agregarle dibujando sobre él.

✅Lea [más sobre la API de Canvas](https://developer.mozilla.org/docs/Web/API/Canvas_API) en MDN.

Así es como se declara normalmente, como parte del cuerpo de la página:

```HTML
<canvas id="myCanvas" width="200" height="100"></canvas>
```

Arriba estamos configurando `id`, `width`y `height`.

- `id`: configure esto para que pueda obtener una referencia cuando necesite interactuar con él.
    
- `width`: este es el ancho del elemento.
    
- `height`: esta es la altura del elemento.
    

## Dibujar geometría simple

El lienzo utiliza un sistema de coordenadas cartesianas para dibujar cosas. Por lo tanto, utiliza un eje x y un eje y para expresar dónde se encuentra algo. La ubicación `0,0`es la posición superior izquierda y la inferior derecha es lo que usted dijo que es el ANCHO y el ALTO del lienzo.

![Canvas](canvas_grid.png)


Para dibujar en el elemento del lienzo, deberá seguir los siguientes pasos:

1. **Obtenga una referencia** al elemento Canvas.
    
2. **Obtenga una referencia** sobre el elemento de contexto que se encuentra en el elemento de lienzo.
    
3. **Realice una operación de dibujo** utilizando el elemento de contexto.
    

El código para los pasos anteriores generalmente se ve así:

```Javascript
// Dibuja un rectángulo rojo
//1. Obtener la referencia de CANVAS
canvas = document.getElementById("myCanvas");

//2. Establezca el contexto en 2D para dibujar formas básicas
ctx = canvas.getContext("2d");

//3. Rellenalo con el color rojo
ctx.fillStyle = 'red';

//4. y dibuja un rectángulo con estos parámetros, configurando ubicación y tamaño
ctx.fillRect(0,0, 200, 200) // x,y,width, height
```

✅La API de Canvas se enfoca principalmente en formas 2D, pero también puede dibujar elementos 3D en un sitio web; para esto, puede usar la [API de WebGL](https://developer.mozilla.org/docs/Web/API/WebGL_API) .

Puede dibujar todo tipo de cosas con la API de Canvas como:

- **Formas geométricas** ya mostramos cómo dibujar un rectángulo, pero hay mucho más que puedes dibujar.
    
- **Texto** puede dibujar un texto con cualquier fuente y color que desee.
    
- **Imágenes**puede dibujar una imagen basada en un recurso de imagen como .jpg o .png, por ejemplo.
    

✅¡Intentalo! Sabes cómo dibujar un rectángulo, ¿puedes dibujar un círculo en una página? Eche un vistazo a algunos dibujos interesantes de Canvas en CodePen. He aquí un [ejemplo particularmente impresionante](https://codepen.io/dissimulate/pen/KrAwx) .

## Cargue y dibuje un recurso de imagen

Carga un activo de imagen creando un `Image`objeto y configurando su `src`propiedad. Luego, escucha el evento `load` para saber cuándo está listo para usarse. El código se ve así:

### Cargar activo

```javascript
const img = new Image();
img.src = 'path/to/my/image.png';
img.onload = () => {
  // Imagen cargada y lista para ser utilizada.
}
```

### Cargar patrón de activos

Se recomienda envolver lo anterior en una construcción como esta, para que sea más fácil de usar y solo intente manipularlo cuando esté completamente cargado:

```javascript
function loadAsset(path) {
  return new Promise((resolve) => {
    const img = new Image();
    img.src = path;
    img.onload = () => {
      // Imagen cargada y lista para ser utilizada.
      resolve(img);
    }
  })
}

// usar así

async function run() {
  const heroImg = await loadAsset('hero.png')
  const monsterImg = await loadAsset('monster.png')
}
```

Para dibujar activos del juego en una pantalla, su código se vería así:

```javascript
async function run() {
  const heroImg = await loadAsset('hero.png')
  const monsterImg = await loadAsset('monster.png')

  canvas = document.getElementById("myCanvas");
  ctx = canvas.getContext("2d");
  ctx.drawImage(heroImg, canvas.width/2,canvas.height/2);
  ctx.drawImage(monsterImg, 0,0);
}
```

## Ahora es el momento de comenzar a construir tu juego.

### que construir

Construirás una página web con un elemento Canvas. Debería mostrar una pantalla negra `1024*768`.Aqui tendrás dos imágenes:

- Nave héroe
    
    ![Nave héroe](../clase16_17_18/assets/player.png)
    
- 5*5 monstruo
    
    ![Nave Monstruo](../clase16_17_18/assets/enemyShip.png)
    

### Pasos recomendados para iniciar el desarrollo

Localice los archivos que se han creado para usted. Debe contener lo siguiente:

```bash
-| assets
  -| enemyShip.png
  -| player.png
-| index.html
-| app.js
-| package.json
```

Abra la copia de esta carpeta en Visual Studio Code. Debe tener una configuración de entorno de desarrollo local, preferiblemente con Visual Studio Code con NPM y Node instalados. Si no lo ha `npm`configurado en su computadora, [aquí le mostramos cómo hacerlo](https://www.npmjs.com/get-npm) .

Comience su proyecto navegando a la carpeta`clase16_17_18`carpeta:

```bash
cd clase16_17_18
npm start
```

Lo anterior iniciará un servidor HTTP en la dirección `http://localhost:5000`. Abre un navegador e ingresa esa dirección. Es una página en blanco en este momento, pero eso cambiará.

> Nota: para ver los cambios en su pantalla, actualice su navegador.
>

### Agregar código

Agregue el código necesario para `clase16_17_18/app.js`resolver lo siguiente

1. **Dibuja** un lienzo con fondo negro.
    
    > consejo: agregue en /app.js, configurando el elemento `ctx` para que sea negro y las coordenadas superior/izquierda estén en 0,0 y la altura y el ancho sean iguales a los de canva.
    > 
2. **Cargar** texturas
    
    > consejo: agregue las imágenes del jugador y del enemigo usando await loadTexturey pasando la ruta de la imagen. ¡Aún no los verás en la pantalla!
    > 
3. **Dibujar** héroe en el centro de la pantalla en la mitad inferior
    
    > consejo: use la drawImageAPI para dibujar hero Img en la pantalla, configurando canvas.width / 2 - 45y canvas.height - canvas.height / 4);
    > 
4. **Dibujar** 5*5 monstruos
    
    > consejo: ahora puedes descomentar el código para dibujar enemigos en la pantalla. A continuación, vaya a la createEnemiesfunción y constrúyala.
    > 
    
    Primero, configure algunas constantes:
    
    ```javascript
    const MONSTER_TOTAL = 5;
    const MONSTER_WIDTH = MONSTER_TOTAL * 98;
    const START_X = (canvas.width - MONSTER_WIDTH) / 2;
    const STOP_X = START_X + MONSTER_WIDTH;
    ```
    
    luego, crea un bucle para dibujar la matriz de monstruos en la pantalla:
    
    ```javascript
    for (let x = START_X; x < STOP_X; x += 98) {
        for (let y = 0; y < 50 * 5; y += 50) {
          ctx.drawImage(enemyImg, x, y);
        }
      }
    ```
    

## Resultado

El resultado final debería verse así:

![Ejemplo resultado primera parte](partI-solution.png)

# Construir un juego espacial Parte 3: agregar movimiento

¡Los juegos no son muy divertidos hasta que tienes extraterrestres corriendo en la pantalla! En este juego, haremos uso de dos tipos de movimientos:

- **Movimiento de teclado/ratón**
    
    : cuando el usuario interactúa con el teclado o el ratón para mover un objeto en la pantalla.
    
- **Movimiento inducido por el juego**
    
    : cuando el juego mueve un objeto con un cierto intervalo de tiempo.
    

Entonces, ¿cómo movemos las cosas en una pantalla? Se trata de coordenadas cartesianas: cambiamos la ubicación (x, y) del objeto y luego volvemos a dibujar la pantalla.

Por lo general, necesita los siguientes pasos para realizar *el movimiento* en una pantalla:

1. **Establecer una nueva ubicación**
    
    para un objeto; esto es necesario para percibir que el objeto se ha movido.
    
2. **Borrar la pantalla**
    
    , la pantalla debe limpiarse entre cada juego. Podemos despejarlo dibujando un rectángulo que rellenamos con un color de fondo.
    
3. **Vuelva a dibujar el objeto**
    
    en la nueva ubicación. Al hacer esto, finalmente logramos mover el objeto de un lugar a otro.
    

Así es como puede verse en el código:

```javascript
//establecer la ubicación del héroe
hero.x += 5;
// Limpia el rectángulo que alberga al héroe.
ctx.clearRect(0, 0, canvas.width, canvas.height);
// volver a dibujar el fondo y el héroe del juego
ctx.fillRect(0, 0, canvas.width, canvas.height)
ctx.fillStyle = "black";
ctx.drawImage(heroImg, hero.x, hero.y);
```

✅¿Puedes pensar en una razón por la que volver a dibujar a tu héroe muchos fotogramas por segundo podría generar costos de rendimiento? Lea acerca de [las alternativas a este patrón](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Optimizing_canvas) .

## Manejar eventos de teclado

Maneja eventos adjuntando eventos específicos al código. Los eventos del teclado se activan en toda la ventana, mientras que los eventos del mouse, como un, `click`se pueden conectar al hacer clic en un elemento específico. Usaremos eventos de teclado a lo largo de este proyecto.

Para manejar un evento, debe usar el método `addEventListener()` y proporcionarle dos parámetros de entrada. El primer parámetro es el nombre del evento, por ejemplo `keyup`. El segundo parámetro es la función que se debe invocar como resultado de que se produzca el evento.

Aquí hay un ejemplo:

```JavaScript
window.addEventListener('keyup', (evt) => {
  // `evt.key` = representación de cadena de la clave
  if (evt.key === 'ArrowUp') {
    // hacer algo
  }
})
```

Para eventos clave, hay dos propiedades en el evento que puede usar para ver qué tecla se presionó:

- `key`
    
    , esta es una representación de cadena de la tecla presionada, por ejemplo `ArrowUp`
    
- `keyCode`
    
    , esta es una representación numérica, por ejemplo 37, corresponde a `ArrowLeft`.
    

✅La manipulación de eventos clave es útil fuera del desarrollo de juegos. ¿Qué otros usos se te ocurren para esta técnica?

### Teclas especiales: una advertencia

Hay algunas teclas *especiales* que afectan a la ventana. Eso significa que si estás escuchando un `keyup`evento y usas estas teclas especiales para mover a tu héroe, también realizará el desplazamiento horizontal. Por esa razón, es posible que desee *desactivar* este comportamiento integrado del navegador a medida que desarrolla su juego. Necesitas un código como este:

```JavaScript
let onKeyDown = function (e) {
  console.log(e.keyCode);
  switch (e.keyCode) {
    case 37:
    case 39:
    case 38:
    case 40: // Teclas de flechas
    case 32: // Tecla espacio
      e.preventDefault();
      break; 
    default:
      break; // No bloquear otras claves
  }
};

window.addEventListener('keydown', onKeyDown);
```
📢 más info sobre el objeto window
- [window](https://developer.mozilla.org/es/docs/Web/API/Window)

El código anterior garantizará que las teclas de flecha y la tecla de espacio tengan su comportamiento *predeterminado* desactivado. El mecanismo *de apagado* ocurre cuando llamamos `e.preventDefault()`.

## Movimiento inducido por el juego

Podemos hacer que las cosas se muevan solas usando temporizadores como la función `setTimeout()`o `setInterval()`que actualiza la ubicación del objeto en cada marca o intervalo de tiempo. Esto es lo que puede parecer:

```JavaScript
let id = setInterval(() => {
  // Mueve al enemigo en el eje y
  enemy.y += 10;
})
```

## el bucle del juego

El bucle del juego es un concepto que es esencialmente una función que se invoca a intervalos regulares. Se llama bucle de juego porque todo lo que debería ser visible para el usuario se dibuja en el bucle. El bucle del juego hace uso de todos los objetos del juego que forman parte del juego, dibujándolos todos a menos que por alguna razón ya no deban ser parte del juego. Por ejemplo, si un objeto es un enemigo que fue golpeado por un láser y explota, ya no forma parte del ciclo actual del juego (aprenderás más sobre esto en lecciones posteriores).

Este es el aspecto típico de un bucle de juego, expresado en código:

```JavaScript
let gameLoopId = setInterval(() =>
  function gameLoop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    drawHero();
    drawEnemies();
    drawStaticObjects();
}, 200);
```

El bucle anterior se invoca cada `200`milisegundos para volver a dibujar el lienzo. Tienes la posibilidad de elegir el mejor intervalo que tenga sentido para tu juego.

## Continuando con el juego espacial

Tomará el código existente y lo ampliará. Comienza con el código que completaste durante la parte I o usa el código en la segunda parte.

- **Mover al héroe**
    
    : agregará código para asegurarse de que puede mover al héroe con las teclas de flecha.
    
- **Mover enemigos**
    
    : también deberá agregar código para asegurarse de que los enemigos se muevan de arriba a abajo a un ritmo determinado.
    

## Pasos recomendados

Localice los archivos que se han creado para usted . Debe contener lo siguiente:

```bash
-| assets
  -| enemyShip.png
  -| player.png
-| index.html
-| app.js
-| package.json
```

Inicia su proyecto en la carpeta escribiendo:

```bash
cd clase16_17_18
npm start
```

Lo anterior iniciará un servidor HTTP en la dirección `http://localhost:5000`. Abra un navegador e ingrese esa dirección, en este momento debería representar al héroe y a todos los enemigos; nada se mueve, ¡todavía!

### Agregar código

1. **Agregue objetos dedicados** para `hero`and `enemy`y `game object`, deben tener propiedades `x`y `y`. (Recordar la parte sobre Herencia o composición.
    
    *SUGERENCIA* `game object` debe ser el que tiene `x`y `y`la capacidad de dibujarse a sí mismo en un lienzo.
    
    > consejo: comience agregando una nueva clase GameObject con su constructor delineado como se muestra a continuación, y luego dibújelo en el lienzo:
    > 
    
    ```JavaScript
    class GameObject {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.dead = false;
        this.type = "";
        this.width = 0;
        this.height = 0;
        this.img = undefined;
      }
    
      draw(ctx) {
        ctx.drawImage(this.img, this.x, this.y, this.width, this.height);
      }
    }
    ```
    
    Ahora, extienda este GameObject para crear el Héroe y el Enemigo.
    
    ```JavaScript
    class Hero extends GameObject {
      constructor(x, y) {
        ...it needs an x, y, type, and speed
      }
    }
    ```
    
    ```JavaScript
    class Enemy extends GameObject {
      constructor(x, y) {
        super(x, y);
        (this.width = 98), (this.height = 50);
        this.type = "Enemy";
        let id = setInterval(() => {
          if (this.y < canvas.height - this.height) {
            this.y += 5;
          } else {
            console.log('Stopped at', this.y)
            clearInterval(id);
          }
        }, 300)
      }
    }
    ```
    
2. **Agregue controladores de eventos clave** para manejar la navegación clave (mover héroe arriba/abajo izquierda/derecha)
    
    *RECUERDE* que es un sistema cartesiano, arriba a la izquierda es `0,0`. También recuerde agregar código para detener *el comportamiento predeterminado*
    
    > consejo: cree su función onKeyDown y adjúntela a la ventana:
    > 
    
    ```JavaScript
     let onKeyDown = function (e) {
           console.log(e.keyCode);
             ...agregue el código de la lección anterior para detener
             default behavior
           }
     };
    
     window.addEventListener("keydown", onKeyDown);
    ```
    
    Verifique la consola de su navegador en este punto y observe cómo se registran las pulsaciones de teclas.
    
3. **Implemente** el patrón Pub/sub , esto mantendrá su código limpio mientras sigue las partes restantes.
    
    Para hacer esta última parte, puedes:
    
    1. **Agregue un detector de eventos** en la ventana:
        
        ```JavaScript
         window.addEventListener("keyup", (evt) => {
           if (evt.key === "ArrowUp") {
             eventEmitter.emit(Messages.KEY_EVENT_UP);
           } else if (evt.key === "ArrowDown") {
             eventEmitter.emit(Messages.KEY_EVENT_DOWN);
           } else if (evt.key === "ArrowLeft") {
             eventEmitter.emit(Messages.KEY_EVENT_LEFT);
           } else if (evt.key === "ArrowRight") {
             eventEmitter.emit(Messages.KEY_EVENT_RIGHT);
           }
         });
        ```
        
    2. **Crea una clase EventEmitter** para publicar y suscribirte a los mensajes:
        
        ```JavaScript
        class EventEmitter {
          constructor() {
            this.listeners = {};
          }
        
          on(message, listener) {
            if (!this.listeners[message]) {
              this.listeners[message] = [];
            }
            this.listeners[message].push(listener);
          }
        
          emit(message, payload = null) {
            if (this.listeners[message]) {
              this.listeners[message].forEach((l) => l(message, payload));
            }
          }
        }
        ```
        
    3. **Agregue constantes** y configure EventEmitter:
        
        ```JavaScript
        const Messages = {
          KEY_EVENT_UP: "KEY_EVENT_UP",
          KEY_EVENT_DOWN: "KEY_EVENT_DOWN",
          KEY_EVENT_LEFT: "KEY_EVENT_LEFT",
          KEY_EVENT_RIGHT: "KEY_EVENT_RIGHT",
        };
        
        let heroImg,
            enemyImg,
            laserImg,
            canvas, ctx,
            gameObjects = [],
            hero,
            eventEmitter = new EventEmitter();
        ```
        
    4. **Inicializar el juego**
    
    ```JavaScript
    function initGame() {
      gameObjects = [];
      createEnemies();
      createHero();
    
      eventEmitter.on(Messages.KEY_EVENT_UP, () => {
        hero.y -=5 ;
      })
    
      eventEmitter.on(Messages.KEY_EVENT_DOWN, () => {
        hero.y += 5;
      });
    
      eventEmitter.on(Messages.KEY_EVENT_LEFT, () => {
        hero.x -= 5;
      });
    
      eventEmitter.on(Messages.KEY_EVENT_RIGHT, () => {
        hero.x += 5;
      });
    }
    ```
    
4. **Configurar el bucle del juego**
    
    Refactorice la función window.onload para inicializar el juego y configurar un bucle de juego en un buen intervalo. También agregará un rayo láser:
    
    ```JavaScript
    window.onload = async () => {
      canvas = document.getElementById("canvas");
      ctx = canvas.getContext("2d");
      heroImg = await loadTexture("assets/player.png");
      enemyImg = await loadTexture("assets/enemyShip.png");
      laserImg = await loadTexture("assets/laserRed.png");
    
      initGame();
      let gameLoopId = setInterval(() => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        drawGameObjects(ctx);
      }, 100)
    
    };
    ```
    
5. **Agregue código** para mover enemigos en un cierto intervalo
    
    Refactorice la `createEnemies()`función para crear los enemigos e introdúzcalos en la nueva clase gameObjects:
    
    ```JavaScript
    function createEnemies() {
      const MONSTER_TOTAL = 5;
      const MONSTER_WIDTH = MONSTER_TOTAL * 98;
      const START_X = (canvas.width - MONSTER_WIDTH) / 2;
      const STOP_X = START_X + MONSTER_WIDTH;
    
      for (let x = START_X; x < STOP_X; x += 98) {
        for (let y = 0; y < 50 * 5; y += 50) {
          const enemy = new Enemy(x, y);
          enemy.img = enemyImg;
          gameObjects.push(enemy);
        }
      }
    }
    ```
    
    y agregue una `createHero()`función para hacer un proceso similar para el héroe.
    
    ```JavaScript
    function createHero() {
      hero = new Hero(
        canvas.width / 2 - 45,
        canvas.height - canvas.height / 4
      );
      hero.img = heroImg;
      gameObjects.push(hero);
    }
    ```
    
    y finalmente, agregue una `drawGameObjects()`función para comenzar el dibujo:
    
    ```JavaScript
    function drawGameObjects(ctx) {
      gameObjects.forEach(go => go.draw(ctx));
    }
    ```
    
    ¡Tus enemigos deberían comenzar a avanzar en tu nave espacial heroica!


