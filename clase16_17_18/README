# Clase 16 - Desarrollando juegos avanzados con js

# Construir un juego espacial Parte 1: Introducci칩n

En esta lecci칩n aprender치s a construir tu propio juego espacial. Si alguna vez has jugado al juego "Space Invaders", este juego tiene la misma idea: dirigir una nave espacial y disparar contra los monstruos que descienden desde arriba.

![video](../clase16_17/images/pewpew.gif)

En estas seis lecciones aprenderemos lo siguiente:

- Interactuar con el elemento Canvas para dibujar cosas en una pantalla
- Comprender el sistema de coordenadas cartesianas
- Aprenda el patr칩n Pub-Sub para crear una arquitectura de juego s칩lida que sea m치s f치cil de mantener y ampliar
- Apalancamiento As칤ncrono/Espera para cargar recursos del juego
- Controlar eventos de teclado

**Descripci칩n general**

- Teor칤a
  - Introducci칩n a la creaci칩n de juegos con JavaScript

- Pr치ctica
  - Dibujar sobre lienzo
  - Mover elementos por la pantalla
  - Detecci칩n de colisiones
  - Manteniendo el marcador
  - Finalizar y reiniciar el juego.

## Introducci칩n ##

### Herencia y composici칩n en el desarrollo de juegos

En lecciones anteriores, no hab칤a mucha necesidad de preocuparse por la arquitectura de dise침o de las aplicaciones que cre칩, ya que los proyectos ten칤an un alcance muy peque침o.Sin embargo, cuando sus aplicaciones crecen en tama침o y alcance, las decisiones arquitect칩nicas se vuelven una preocupaci칩n mayor.Hay dos enfoques principales para crear aplicaciones m치s grandes en JavaScript:*composici칩n*맖*herencia*.ㅁmbos tienen pros y contras, pero vamos a explicarlos desde el contexto de un juego.

九Uno de los libros de programaci칩n m치s famosos jam치s escritos tiene que ver con[los patrones de dise침o](https://en.wikipedia.org/wiki/Design_Patterns).

En un juego tienes`game objects`que son objetos que existen en una pantalla.Esto significa que tienen una ubicaci칩n en un sistema de coordenadas cartesianas, caracterizado por tener una coordenada`x`y`y`.ㅁ medida que desarrolle un juego, notar치 que todos sus objetos de juego tienen una propiedad est치ndar, com칰n para cada juego que crea, elementos que son:

- **basado en la ubicaci칩n**`xy`
  La mayor칤a de los elementos del juego, si no todos, se basan en la ubicaci칩n.Esto significa que tienen una ubicaci칩n, un `x` e `y`.
- **movible**
  Estos son objetos que pueden moverse a una nueva ubicaci칩n.Suele ser un h칠roe, un monstruo o un NPC (un personaje que no es jugador), pero no, por ejemplo, un objeto est치tico como un 치rbol.
- **autodestrucci칩n**`deaddestroyed`
  Estos objetos solo existen durante un per칤odo de tiempo determinado antes de configurarse para su eliminaci칩n.Por lo general, esto se representa mediante un valor booleano `dead` o `destroyed` que indica al motor del juego que este objeto ya no debe representarse.
- **cool-down**
  `Cool-down` es una propiedad t칤pica entre los objetos de vida corta.Un ejemplo t칤pico es un texto o un efecto gr치fico como una explosi칩n que solo deber칤a verse durante unos pocos milisegundos.

九Piensa en un juego como Pac-Man.먝쯇uedes identificar los cuatro tipos de objetos mencionados anteriormente en este juego?

### Expresando comportamiento

Todo lo que describimos anteriormente es el comportamiento que pueden tener los objetos del juego.Entonces, 쯖칩mo los codificamos?Podemos expresar este comportamiento como m칠todos asociados a clases u objetos.

**Clases**

La idea es usar`classes`en conjunto con`inheritance`para lograr agregar un cierto comportamiento a una clase.

九La herencia es un concepto importante de entender.Obt칠n m치s informaci칩n en[el art칤culo de MDN sobre la herencia](https://developer.mozilla.org/docs/Web/JavaScript/Inheritance_and_the_prototype_chain).

Expresado a trav칠s de c칩digo, un objeto de juego normalmente puede tener este aspecto:

```javascript
//configurar la clase GameObject
class GameObject {
  constructor(x, y, type) {
    this.x = x;
    this.y = y;
    this.type = type;
  }
}

//esta clase ampliar치 las propiedades de clase inherentes del GameObject
class Movable extends GameObject {
  constructor(x,y, type) {
    super(x,y, type)
  }

//este objeto m칩vil se puede mover en la pantalla
  moveTo(x, y) {
    this.x = x;
    this.y = y;
  }
}

//esta es una clase espec칤fica que extiende la clase Movable, por lo que puede aprovechar todas las propiedades que hereda
class Hero extends Movable {
  constructor(x,y) {
    super(x,y, 'Hero')
  }
}

//esta clase, por otro lado, s칩lo hereda las propiedades de GameObject
class Tree extends GameObject {
  constructor(x,y) {
    super(x,y, 'Tree')
  }
}

//un h칠roe puede moverse..
const hero = new Hero();
hero.moveTo(5,5);

//pero un 치rbol no puede
const tree = new Tree();
```

九T칩mese unos minutos para volver a imaginar un h칠roe de Pac-Man (Inky, Pinky o Blinky, por ejemplo) y c칩mo se escribir칤a en JavaScript.

**Composici칩n**

Una forma diferente de manejar la herencia de objetos es mediante el uso*de Composici칩n*.Entonces, los objetos expresan su comportamiento as칤:

```javascript
//crear un objeto de gameObject
const gameObject = {
  x: 0,
  y: 0,
  type: ''
};

//...y un movimiento constante 
const movable = {
  moveTo(x, y) {
    this.x = x;
    this.y = y;
  }
}
//entonces la constante movableObject se compone de gameObject y constantes m칩viles
const movableObject = {...gameObject, ...movable};

//luego cree una funci칩n para crear un nuevo h칠roe que herede las propiedades de movableObject
function createHero(x, y) {
  return {
    ...movableObject,
    x,
    y,
    type: 'Hero'
  }
}
//... y un objeto est치tico que hereda s칩lo las propiedades de gameObject
function createStatic(x, y, type) {
  return {
    ...gameObject
    x,
    y,
    type
  }
}
//crea el h칠roe y mu칠velo
const hero = createHero(10,10);
hero.moveTo(5,5);
//and create a static tree which only stands around
const tree = createStatic(0,0, 'Tree');
```

**쯈u칠 patr칩n debo usar?**

Depende de ti qu칠 patr칩n eliges.JavaScript admite ambos paradigmas.

Otro patr칩n com칰n en el desarrollo de juegos aborda el problema de manejar la experiencia y el rendimiento del usuario del juego.

## Patr칩n de publicaci칩n/suscripci칩n

九Pub/Sub significa 'publicar-suscribir'

Este patr칩n aborda la idea de que las partes dispares de su aplicaci칩n no deber칤an conocerse entre s칤.먝쯇orqu칠 es eso?Hace que sea mucho m치s f치cil ver lo que sucede en general si se separan varias partes.Tambi칠n hace que sea m치s f치cil cambiar repentinamente el comportamiento si es necesario.먝쮺칩mo logramos esto?Esto lo hacemos estableciendo algunos conceptos:

- **mensaje** 
  :un mensaje suele ser una cadena de texto acompa침ada de una carga 칰til opcional (un dato que aclara de qu칠 se trata el mensaje).Un mensaje t칤pico en un juego puede ser `KEY_PRESSED_ENTER`
  .
- **editor**
  : este elemento publica  un mensaje y lo env칤a a todos los suscriptores.
- **suscriptor**
  : este elemento escucha mensajes espec칤ficos y realiza alguna tarea como resultado de recibir este mensaje, como disparar un l치ser.

La implementaci칩n es bastante peque침a en tama침o pero es un patr칩n muy poderoso.ㅁs칤 es como se puede implementar:

```javascript
//configurar una clase EventEmitter que contenga oyentes
class EventEmitter {
  constructor() {
    this.listeners = {};
  }
//cuando se recibe un mensaje, deja que el oyente maneje su carga 칰til
  on(message, listener) {
    if (!this.listeners[message]) {
      this.listeners[message] = [];
    }
    this.listeners[message].push(listener);
  }
//cuando se env칰a un mensaje, env칤alo a un oyente con alguna carga 칰til
  emit(message, payload = null) {
    if (this.listeners[message]) {
      this.listeners[message].forEach(l => l(message, payload))
    }
  }
}
```

Para usar el c칩digo anterior, podemos crear una implementaci칩n muy peque침a:

```javascript
//configurar una estructura de mensaje
const Messages = {
  HERO_MOVE_LEFT: 'HERO_MOVE_LEFT'
};
//invoca el eventEmitter que configuraste anteriormente
const eventEmitter = new EventEmitter();
//establecer un h칠roe
const hero = createHero(0,0);
//informar al eventEmitter que est칠 atento a los mensajes relacionados con el h칠roe que se mueve hacia la izquierda y act칰e en consecuencia.
eventEmitter.on(Messages.HERO_MOVE_LEFT, () => {
  hero.move(5,0);
});

//configure la ventana para escuchar el evento de tecla, espec칤ficamente si se presiona la flecha izquierda, emita un mensaje para mover al h칠roe hacia la izquierda
window.addEventListener('keyup', (evt) => {
  if (evt.key === 'ArrowLeft') {
    eventEmitter.emit(Messages.HERO_MOVE_LEFT)
  }
});
```

Arriba conectamos un evento de teclado`ArrowLeft`y enviamos el`HERO_MOVE_LEFT`mensaje.Escuchamos ese mensaje y lo movemos`hero`como resultado.El punto fuerte de este patr칩n es que el oyente del evento y el h칠roe no se conocen.Puede reasignar el`ArrowLeft`a la`A`clave.ㅁdem치s, ser칤a posible hacer algo completamente diferente`ArrowLeft`haciendo algunas ediciones en la`on`funci칩n de eventEmitter:

```javascript
eventEmitter.on(Messages.HERO_MOVE_LEFT, () => {
  hero.move(5,0);
});
```

A medida que las cosas se vuelven m치s complicadas cuando tu juego crece, este patr칩n se mantiene igual en complejidad y tu c칩digo se mantiene limpio.Es muy recomendable adoptar este patr칩n.



# Construye un juego espacial, parte 2: dibuja h칠roes y monstruos en el lienzo

## Canva

Canva (lienzo) es un elemento HTML que por defecto no tiene contenido;만s una pizarra en blanco.Necesitas agregarle dibujando sobre 칠l.

九Lea[m치s sobre la API de Canvas](https://developer.mozilla.org/docs/Web/API/Canvas_API)만n MDN.

As칤 es como se declara normalmente, como parte del cuerpo de la p치gina:

```HTML
<canvas id="myCanvas" width="200" height="100"></canvas>
```

Arriba estamos configurando`id`,`width`y`height`.

- `id`: configure esto para que pueda obtener una referencia cuando necesite interactuar con 칠l.
    
- `width`: este es el ancho del elemento.
    
- `height`: esta es la altura del elemento.
    

## Dibujar geometr칤a simple

El lienzo utiliza un sistema de coordenadas cartesianas para dibujar cosas.Por lo tanto, utiliza un eje x y un eje y para expresar d칩nde se encuentra algo.La ubicaci칩n`0,0`es la posici칩n superior izquierda y la inferior derecha es lo que usted dijo que es el ANCHO y el ALTO del lienzo.

![Canvas](canvas_grid.png)


Para dibujar en el elemento del lienzo, deber치 seguir los siguientes pasos:

1. **Obtenga una referencia** al elemento Canvas.
    
2. **Obtenga una referencia** sobre el elemento de contexto que se encuentra en el elemento de lienzo.
    
3. **Realice una operaci칩n de dibujo** utilizando el elemento de contexto.
    

El c칩digo para los pasos anteriores generalmente se ve as칤:

```Javascript
// Dibuja un rect치ngulo rojo
//1. Obtener la referencia de CANVAS
canvas = document.getElementById("myCanvas");

//2. Establezca el contexto en 2D para dibujar formas b치sicas
ctx = canvas.getContext("2d");

//3. Rellenalo con el color rojo
ctx.fillStyle = 'red';

//4. y dibuja un rect치ngulo con estos par치metros, configurando ubicaci칩n y tama침o
ctx.fillRect(0,0, 200, 200) // x,y,width, height
```

九La API de Canvas se enfoca principalmente en formas 2D, pero tambi칠n puede dibujar elementos 3D en un sitio web;맗ara esto, puede usar la[API de WebGL](https://developer.mozilla.org/docs/Web/API/WebGL_API).

Puede dibujar todo tipo de cosas con la API de Canvas como:

- **Formas geom칠tricas** ya mostramos c칩mo dibujar un rect치ngulo, pero hay mucho m치s que puedes dibujar.
    
- **Texto** puede dibujar un texto con cualquier fuente y color que desee.
    
- **Im치genes**puede dibujar una imagen basada en un recurso de imagen como .jpg o .png, por ejemplo.
    

九춰Intentalo!Sabes c칩mo dibujar un rect치ngulo, 쯣uedes dibujar un c칤rculo en una p치gina?Eche un vistazo a algunos dibujos interesantes de Canvas en CodePen.He aqu칤 un[ejemplo particularmente impresionante](https://codepen.io/dissimulate/pen/KrAwx).

## Cargue y dibuje un recurso de imagen

Carga un activo de imagen creando un`Image`objeto y configurando su`src`propiedad.Luego, escucha el만vento `load` para saber cu치ndo est치 listo para usarse.El c칩digo se ve as칤:

### Cargar activo

```javascript
const img = new Image();
img.src = 'path/to/my/image.png';
img.onload = () => {
  // Imagen cargada y lista para ser utilizada.
}
```

### Cargar patr칩n de activos

Se recomienda envolver lo anterior en una construcci칩n como esta, para que sea m치s f치cil de usar y solo intente manipularlo cuando est칠 completamente cargado:

```javascript
function loadAsset(path) {
  return new Promise((resolve) => {
    const img = new Image();
    img.src = path;
    img.onload = () => {
      // Imagen cargada y lista para ser utilizada.
      resolve(img);
    }
  })
}

// usar as칤

async function run() {
  const heroImg = await loadAsset('hero.png')
  const monsterImg = await loadAsset('monster.png')
}
```

Para dibujar activos del juego en una pantalla, su c칩digo se ver칤a as칤:

```javascript
async function run() {
  const heroImg = await loadAsset('hero.png')
  const monsterImg = await loadAsset('monster.png')

  canvas = document.getElementById("myCanvas");
  ctx = canvas.getContext("2d");
  ctx.drawImage(heroImg, canvas.width/2,canvas.height/2);
  ctx.drawImage(monsterImg, 0,0);
}
```

## Ahora es el momento de comenzar a construir tu juego.

### que construir

Construir치s una p치gina web con un elemento Canvas.Deber칤a mostrar una pantalla negra`1024*768`.Aqui tendr치s dos im치genes:

- Nave h칠roe
    
    ![Nave h칠roe](../clase16_17_18/assets/player.png)
    
- 5*5 monstruo
    
    ![Nave Monstruo](../clase16_17_18/assets/enemyShip.png)
    

### Pasos recomendados para iniciar el desarrollo

Localice los archivos que se han creado para usted.Debe contener lo siguiente:

```bash
-| assets
  -| enemyShip.png
  -| player.png
-| index.html
-| app.js
-| package.json
```

Abra la copia de esta carpeta en Visual Studio Code.Debe tener una configuraci칩n de entorno de desarrollo local, preferiblemente con Visual Studio Code con NPM y Node instalados.Si no lo ha`npm`configurado en su computadora,[aqu칤 le mostramos c칩mo hacerlo](https://www.npmjs.com/get-npm).

Comience su proyecto navegando a la맊arpeta`clase16_17_18`carpeta:

```bash
cd clase16_17_18
npm start
```

Lo anterior iniciar치 un servidor HTTP en la direcci칩n`http://localhost:5000`.ㅁbre un navegador e ingresa esa direcci칩n.Es una p치gina en blanco en este momento, pero eso cambiar치.

> Nota: para ver los cambios en su pantalla, actualice su navegador.
>

### Agregar c칩digo

Agregue el c칩digo necesario para`clase16_17_18/app.js`resolver lo siguiente

1. **Dibuja**맛n lienzo con fondo negro.
    
    > consejo: agregue en/app.js, configurando el elemento`ctx` para que sea negro y las coordenadas superior/izquierda est칠n en 0,0 y la altura y el ancho sean iguales a los de canva.
    > 
2. **Cargar**맚exturas
    
    > consejo: agregue las im치genes del jugador y del enemigo usando마wait loadTexturey pasando la ruta de la imagen.먝메칰n no los ver치s en la pantalla!
    > 
3. **Dibujar**맏칠roe en el centro de la pantalla en la mitad inferior
    
    > consejo: use la맋rawImageAPI para dibujar hero Img en la pantalla, configurando맊anvas.width / 2 - 45y맊anvas.height - canvas.height / 4);
    > 
4. **Dibujar**5*5 monstruos
    
    > consejo: ahora puedes descomentar el c칩digo para dibujar enemigos en la pantalla.ㅁ continuaci칩n, vaya a la맊reateEnemiesfunci칩n y constr칰yala.
    > 
    
    Primero, configure algunas constantes:
    
    ```javascript
    const MONSTER_TOTAL = 5;
    const MONSTER_WIDTH = MONSTER_TOTAL * 98;
    const START_X = (canvas.width - MONSTER_WIDTH) / 2;
    const STOP_X = START_X + MONSTER_WIDTH;
    ```
    
    luego, crea un bucle para dibujar la matriz de monstruos en la pantalla:
    
    ```javascript
    for (let x = START_X; x < STOP_X; x += 98) {
        for (let y = 0; y < 50 * 5; y += 50) {
          ctx.drawImage(enemyImg, x, y);
        }
      }
    ```
    

## Resultado

El resultado final deber칤a verse as칤:

![Ejemplo resultado primera parte](partI-solution.png)

# Construir un juego espacial Parte 3: agregar movimiento

춰Los juegos no son muy divertidos hasta que tienes extraterrestres corriendo en la pantalla!En este juego, haremos uso de dos tipos de movimientos:

- **Movimiento de teclado/rat칩n**
    
    : cuando el usuario interact칰a con el teclado o el rat칩n para mover un objeto en la pantalla.
    
- **Movimiento inducido por el juego**
    
    : cuando el juego mueve un objeto con un cierto intervalo de tiempo.
    

Entonces, 쯖칩mo movemos las cosas en una pantalla?Se trata de coordenadas cartesianas: cambiamos la ubicaci칩n (x, y) del objeto y luego volvemos a dibujar la pantalla.

Por lo general, necesita los siguientes pasos para realizar*el movimiento*만n una pantalla:

1. **Establecer una nueva ubicaci칩n**
    
    para un objeto;만sto es necesario para percibir que el objeto se ha movido.
    
2. **Borrar la pantalla**
    
    , la pantalla debe limpiarse entre cada juego.Podemos despejarlo dibujando un rect치ngulo que rellenamos con un color de fondo.
    
3. **Vuelva a dibujar el objeto**
    
    en la nueva ubicaci칩n.ㅁl hacer esto, finalmente logramos mover el objeto de un lugar a otro.
    

As칤 es como puede verse en el c칩digo:

```javascript
//establecer la ubicaci칩n del h칠roe
hero.x += 5;
// Limpia el rect치ngulo que alberga al h칠roe.
ctx.clearRect(0, 0, canvas.width, canvas.height);
// volver a dibujar el fondo y el h칠roe del juego
ctx.fillRect(0, 0, canvas.width, canvas.height)
ctx.fillStyle = "black";
ctx.drawImage(heroImg, hero.x, hero.y);
```

九쯇uedes pensar en una raz칩n por la que volver a dibujar a tu h칠roe muchos fotogramas por segundo podr칤a generar costos de rendimiento?Lea acerca de[las alternativas a este patr칩n](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Optimizing_canvas).

## Manejar eventos de teclado

Maneja eventos adjuntando eventos espec칤ficos al c칩digo.Los eventos del teclado se activan en toda la ventana, mientras que los eventos del mouse, como un,`click`se pueden conectar al hacer clic en un elemento espec칤fico.Usaremos eventos de teclado a lo largo de este proyecto.

Para manejar un evento, debe usar el맔칠todo `addEventListener()` y proporcionarle dos par치metros de entrada.El primer par치metro es el nombre del evento, por ejemplo`keyup`.El segundo par치metro es la funci칩n que se debe invocar como resultado de que se produzca el evento.

Aqu칤 hay un ejemplo:

```JavaScript
window.addEventListener('keyup', (evt) => {
  // `evt.key` = representaci칩n de cadena de la clave
  if (evt.key === 'ArrowUp') {
    // hacer algo
  }
})
```

Para eventos clave, hay dos propiedades en el evento que puede usar para ver qu칠 tecla se presion칩:

- `key`
    
    , esta es una representaci칩n de cadena de la tecla presionada, por ejemplo `ArrowUp`
    
- `keyCode`
    
    , esta es una representaci칩n num칠rica, por ejemplo 37, corresponde a `ArrowLeft`.
    

九La manipulaci칩n de eventos clave es 칰til fuera del desarrollo de juegos.먝쯈u칠 otros usos se te ocurren para esta t칠cnica?

### Teclas especiales: una advertencia

Hay algunas teclas*especiales*맘ue afectan a la ventana.Eso significa que si est치s escuchando un`keyup`evento y usas estas teclas especiales para mover a tu h칠roe, tambi칠n realizar치 el desplazamiento horizontal.Por esa raz칩n, es posible que desee*desactivar*만ste comportamiento integrado del navegador a medida que desarrolla su juego.Necesitas un c칩digo como este:

```JavaScript
let onKeyDown = function (e) {
  console.log(e.keyCode);
  switch (e.keyCode) {
    case 37:
    case 39:
    case 38:
    case 40: // Teclas de flechas
    case 32: // Tecla espacio
      e.preventDefault();
      break; 
    default:
      break; // No bloquear otras claves
  }
};

window.addEventListener('keydown', onKeyDown);
```
游닉 m치s info sobre el objeto window
- [window](https://developer.mozilla.org/es/docs/Web/API/Window)

El c칩digo anterior garantizar치 que las teclas de flecha y la tecla de espacio tengan su comportamiento*predeterminado*맋esactivado.El mecanismo*de apagado*맖curre cuando llamamos`e.preventDefault()`.

## Movimiento inducido por el juego

Podemos hacer que las cosas se muevan solas usando temporizadores como la funci칩n`setTimeout()`o`setInterval()`que actualiza la ubicaci칩n del objeto en cada marca o intervalo de tiempo.Esto es lo que puede parecer:

```JavaScript
let id = setInterval(() => {
  // Mueve al enemigo en el eje y
  enemy.y += 10;
})
```

## el bucle del juego

El bucle del juego es un concepto que es esencialmente una funci칩n que se invoca a intervalos regulares.Se llama bucle de juego porque todo lo que deber칤a ser visible para el usuario se dibuja en el bucle.El bucle del juego hace uso de todos los objetos del juego que forman parte del juego, dibuj치ndolos todos a menos que por alguna raz칩n ya no deban ser parte del juego.Por ejemplo, si un objeto es un enemigo que fue golpeado por un l치ser y explota, ya no forma parte del ciclo actual del juego (aprender치s m치s sobre esto en lecciones posteriores).

Este es el aspecto t칤pico de un bucle de juego, expresado en c칩digo:

```JavaScript
let gameLoopId = setInterval(() =>
  function gameLoop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    drawHero();
    drawEnemies();
    drawStaticObjects();
}, 200);
```

El bucle anterior se invoca cada`200`milisegundos para volver a dibujar el lienzo.Tienes la posibilidad de elegir el mejor intervalo que tenga sentido para tu juego.

## Continuando con el juego espacial

Tomar치 el c칩digo existente y lo ampliar치.Comienza con el c칩digo que completaste durante la parte I o usa el c칩digo en맓a segunda parte.

- **Mover al h칠roe**
    
    : agregar치 c칩digo para asegurarse de que puede mover al h칠roe con las teclas de flecha.
    
- **Mover enemigos**
    
    : tambi칠n deber치 agregar c칩digo para asegurarse de que los enemigos se muevan de arriba a abajo a un ritmo determinado.
    

## Pasos recomendados

Localice los archivos que se han creado para usted .Debe contener lo siguiente:

```bash
-| assets
  -| enemyShip.png
  -| player.png
-| index.html
-| app.js
-| package.json
```

Inicia su proyecto en la맊arpeta escribiendo:

```bash
cd clase16_17_18
npm start
```

Lo anterior iniciar치 un servidor HTTP en la direcci칩n`http://localhost:5000`.ㅁbra un navegador e ingrese esa direcci칩n, en este momento deber칤a representar al h칠roe y a todos los enemigos;맕ada se mueve, 춰todav칤a!

### Agregar c칩digo

1. **Agregue objetos dedicados**맗ara`hero`and`enemy`y`game object`, deben tener propiedades`x`y`y`.(Recordar la parte sobreHerencia o composici칩n.
    
    *SUGERENCIA*`game object`맋ebe ser el que tiene`x`y`y`la capacidad de dibujarse a s칤 mismo en un lienzo.
    
    > consejo: comience agregando una nueva clase GameObject con su constructor delineado como se muestra a continuaci칩n, y luego dib칰jelo en el lienzo:
    > 
    
    ```JavaScript
    class GameObject {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.dead = false;
        this.type = "";
        this.width = 0;
        this.height = 0;
        this.img = undefined;
      }
    
      draw(ctx) {
        ctx.drawImage(this.img, this.x, this.y, this.width, this.height);
      }
    }
    ```
    
    Ahora, extienda este GameObject para crear el H칠roe y el Enemigo.
    
    ```JavaScript
    class Hero extends GameObject {
      constructor(x, y) {
        ...it needs an x, y, type, and speed
      }
    }
    ```
    
    ```JavaScript
    class Enemy extends GameObject {
      constructor(x, y) {
        super(x, y);
        (this.width = 98), (this.height = 50);
        this.type = "Enemy";
        let id = setInterval(() => {
          if (this.y < canvas.height - this.height) {
            this.y += 5;
          } else {
            console.log('Stopped at', this.y)
            clearInterval(id);
          }
        }, 300)
      }
    }
    ```
    
2. **Agregue controladores de eventos clave**맗ara manejar la navegaci칩n clave (mover h칠roe arriba/abajo izquierda/derecha)
    
    *RECUERDE*맘ue es un sistema cartesiano, arriba a la izquierda es`0,0`.Tambi칠n recuerde agregar c칩digo para detener*el comportamiento predeterminado*
    
    > consejo: cree su funci칩n onKeyDown y adj칰ntela a la ventana:
    > 
    
    ```JavaScript
     let onKeyDown = function (e) {
           console.log(e.keyCode);
             ...agregue el c칩digo de la lecci칩n anterior para detener
             default behavior
           }
     };
    
     window.addEventListener("keydown", onKeyDown);
    ```
    
    Verifique la consola de su navegador en este punto y observe c칩mo se registran las pulsaciones de teclas.
    
3. **Implemente**만l맗atr칩n Pub/sub, esto mantendr치 su c칩digo limpio mientras sigue las partes restantes.
    
    Para hacer esta 칰ltima parte, puedes:
    
    1. **Agregue un detector de eventos**만n la ventana:
        
        ```JavaScript
         window.addEventListener("keyup", (evt) => {
           if (evt.key === "ArrowUp") {
             eventEmitter.emit(Messages.KEY_EVENT_UP);
           } else if (evt.key === "ArrowDown") {
             eventEmitter.emit(Messages.KEY_EVENT_DOWN);
           } else if (evt.key === "ArrowLeft") {
             eventEmitter.emit(Messages.KEY_EVENT_LEFT);
           } else if (evt.key === "ArrowRight") {
             eventEmitter.emit(Messages.KEY_EVENT_RIGHT);
           }
         });
        ```
        
    2. **Crea una clase EventEmitter**맗ara publicar y suscribirte a los mensajes:
        
        ```JavaScript
        class EventEmitter {
          constructor() {
            this.listeners = {};
          }
        
          on(message, listener) {
            if (!this.listeners[message]) {
              this.listeners[message] = [];
            }
            this.listeners[message].push(listener);
          }
        
          emit(message, payload = null) {
            if (this.listeners[message]) {
              this.listeners[message].forEach((l) => l(message, payload));
            }
          }
        }
        ```
        
    3. **Agregue constantes**맟 configure EventEmitter:
        
        ```JavaScript
        const Messages = {
          KEY_EVENT_UP: "KEY_EVENT_UP",
          KEY_EVENT_DOWN: "KEY_EVENT_DOWN",
          KEY_EVENT_LEFT: "KEY_EVENT_LEFT",
          KEY_EVENT_RIGHT: "KEY_EVENT_RIGHT",
        };
        
        let heroImg,
            enemyImg,
            laserImg,
            canvas, ctx,
            gameObjects = [],
            hero,
            eventEmitter = new EventEmitter();
        ```
        
    4. **Inicializar el juego**
    
    ```JavaScript
    function initGame() {
      gameObjects = [];
      createEnemies();
      createHero();
    
      eventEmitter.on(Messages.KEY_EVENT_UP, () => {
        hero.y -=5 ;
      })
    
      eventEmitter.on(Messages.KEY_EVENT_DOWN, () => {
        hero.y += 5;
      });
    
      eventEmitter.on(Messages.KEY_EVENT_LEFT, () => {
        hero.x -= 5;
      });
    
      eventEmitter.on(Messages.KEY_EVENT_RIGHT, () => {
        hero.x += 5;
      });
    }
    ```
    
4. **Configurar el bucle del juego**
    
    Refactorice la funci칩n window.onload para inicializar el juego y configurar un bucle de juego en un buen intervalo.Tambi칠n agregar치 un rayo l치ser:
    
    ```JavaScript
    window.onload = async () => {
      canvas = document.getElementById("canvas");
      ctx = canvas.getContext("2d");
      heroImg = await loadTexture("assets/player.png");
      enemyImg = await loadTexture("assets/enemyShip.png");
      laserImg = await loadTexture("assets/laserRed.png");
    
      initGame();
      let gameLoopId = setInterval(() => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        drawGameObjects(ctx);
      }, 100)
    
    };
    ```
    
5. **Agregue c칩digo**맗ara mover enemigos en un cierto intervalo
    
    Refactorice la`createEnemies()`funci칩n para crear los enemigos e introd칰zcalos en la nueva clase gameObjects:
    
    ```JavaScript
    function createEnemies() {
      const MONSTER_TOTAL = 5;
      const MONSTER_WIDTH = MONSTER_TOTAL * 98;
      const START_X = (canvas.width - MONSTER_WIDTH) / 2;
      const STOP_X = START_X + MONSTER_WIDTH;
    
      for (let x = START_X; x < STOP_X; x += 98) {
        for (let y = 0; y < 50 * 5; y += 50) {
          const enemy = new Enemy(x, y);
          enemy.img = enemyImg;
          gameObjects.push(enemy);
        }
      }
    }
    ```
    
    y agregue una`createHero()`funci칩n para hacer un proceso similar para el h칠roe.
    
    ```JavaScript
    function createHero() {
      hero = new Hero(
        canvas.width / 2 - 45,
        canvas.height - canvas.height / 4
      );
      hero.img = heroImg;
      gameObjects.push(hero);
    }
    ```
    
    y finalmente, agregue una`drawGameObjects()`funci칩n para comenzar el dibujo:
    
    ```JavaScript
    function drawGameObjects(ctx) {
      gameObjects.forEach(go => go.draw(ctx));
    }
    ```
    
    ## 춰Tus enemigos deber칤an comenzar a avanzar en tu nave espacial heroica! 游游

  # Construir un juego espacial Parte 4: agregar un l치ser y detectar colisiones

춰En esta lecci칩n aprender치 a disparar l치seres con JavaScript!ㅁgregaremos dos cosas a nuestro juego:

- **Un l치ser**
    
    : este l치ser se dispara desde la nave de tus h칠roes y verticalmente hacia arriba.
    
- **Detecci칩n de colisi칩n***disparar*
    
    , como parte de la implementaci칩n de la capacidad de
    
    , tambi칠n agregaremos algunas reglas de juego agradables:
    
    - **El l치ser golpea al enemigo**
        
        : el enemigo muere si es golpeado por un l치ser.
        
    - **El l치ser golpea la pantalla superior**
        
        : un l치ser se destruye si golpea la parte superior de la pantalla
        
    - **Colisi칩n de h칠roe y enemigo**
        
        : un enemigo y el h칠roe se destruyen si se golpean entre s칤.
        
    - **El enemigo golpea la parte inferior de la pantalla**
        
        : un enemigo y un h칠roe son destruidos si el enemigo golpea la parte inferior de la pantalla.
        

En resumen, t칰,*el h칠roe*, debes golpear a todos los enemigos con un l치ser antes de que logren moverse hacia la parte inferior de la pantalla.

九Investigue un poco sobre el primer juego de computadora jam치s escrito.먝쮺u치l era su funcionalidad?

## Detecci칩n de colisiones

쮺칩mo hacemos la detecci칩n de colisiones?Necesitamos pensar en los objetos de nuestro juego como rect치ngulos que se mueven.먝쯇or qu칠 es as칤 te preguntar치s?Bueno, la imagen que se맛sa para dibujar un objeto de juego es un rect치ngulo: tiene`x`,맟`y` `width` `height`

Si dos rect치ngulos, es decir, un h칠roe y un enemigo*se cruzan*, tienes una colisi칩n.Lo que deber칤a suceder entonces depende de las reglas del juego.Por lo tanto, para implementar la detecci칩n de colisiones, necesita lo siguiente:

1. Una forma de obtener una representaci칩n rectangular de un objeto del juego, algo como esto:
    
    ```JavaScript
    rectFromGameObject() {
      return {
        top: this.y,
        left: this.x,
        bottom: this.y + this.height,
        right: this.x + this.width
      }
    }
    ```
    
2. Una funci칩n de comparaci칩n, esta funci칩n puede verse as칤:
    
    ```Javascript
    function intersectRect(r1, r2) {
      return !(r2.left > r1.right ||
        r2.right < r1.left ||
        r2.top > r1.bottom ||
        r2.bottom < r1.top);
    }
    ```
    

## 쮺칩mo destruimos las cosas?

Para destruir cosas en un juego, debe informar al juego que ya no debe pintar este elemento en el ciclo del juego que se activa en un intervalo determinado.Una forma de hacer esto es marcar un objeto del juego como*muerto*맊uando sucede algo, as칤:

```JavaScript
// ocurri칩 la colisi칩n
enemy.dead = true
```

Luego, puede proceder a clasificar los objetos*muertos*마ntes de volver a pintar la pantalla, as칤:

```JavaScript
gameObjects = gameObject.filter(go => !go.dead);
```

## 쮺칩mo disparamos un l치ser?

Disparar un l치ser se traduce en responder a un evento clave y crear un objeto que se mueve en una direcci칩n determinada.Por lo tanto, debemos llevar a cabo los siguientes pasos:

1. **Crea un objeto l치ser**
    
    : desde la parte superior de la nave de nuestro h칠roe, que al crearse comienza a moverse hacia arriba, hacia la parte superior de la pantalla.
    
2. **Adjuntar c칩digo a un evento clave**
    
    : debemos elegir una tecla en el teclado que represente al jugador disparando el l치ser.
    
3. **Crea un objeto de juego que parece un l치ser**
    
    cuando se presiona la tecla.
    

## Enfriamiento en nuestro l치ser

El l치ser debe dispararse cada vez que presiona una tecla, como*espacio*, por ejemplo.Para evitar que el juego produzca demasiados l치seres en poco tiempo, debemos solucionar este problema.La soluci칩n es implementar un llamado*enfriamiento*, un temporizador, que garantiza que un l치ser solo se pueda disparar con cierta frecuencia.Puedes implementar eso de la siguiente manera:

```JavaScript
class Cooldown {
  constructor(time) {
    this.cool = false;
    setTimeout(() => {
      this.cool = true;
    }, time)
  }
}

class Weapon {
  constructor {
  }
  fire() {
    if (!this.cooldown || this.cooldown.cool) {
      // Producir un l치ser
      this.cooldown = new Cooldown(500);
    } else {
      // no hagas nada, todav칤a no se ha enfriado.
    }
  }
}
```

九Consulte la lecci칩n 1 de la serie de juegos espaciales para recordar los*tiempos de reutilizaci칩n*.

## que construir

Tomar치 el c칩digo existente (que deber칤a haber limpiado y refactorizado) de la lecci칩n anterior y lo ampliar치.Empiece con el c칩digo de la Parte II o utilice el c칩digo de맓a Parte III

> consejo: el l치ser con el que trabajar치 ya est치 en su carpeta de activos y su c칩digo hace referencia a 칠l
> 

- **Agregue detecci칩n de colisi칩n**
    
    , cuando un l치ser colisiona con algo, se deben aplicar las siguientes reglas:
    
    1. **El l치ser golpea al enemigo**
        
        : el enemigo muere si es golpeado por un l치ser.
        
    2. **Laser hits top screen**
        
        : Un l치ser se destruye si golpea la parte superior de nuestra pantalla
        
    3. **Colisi칩n de h칠roe y enemigo**
        
        : un enemigo y el h칠roe se destruyen si se golpean entre s칤
        
    4. **El enemigo golpea la parte inferior de la pantalla**
        
        : un enemigo y un h칠roe se destruyen si el enemigo golpea la parte inferior de la pantalla.
        

## Pasos recomendados

Localice los archivos que se han creado para usted.Debe contener lo siguiente:

```bash
-| assets
  -| enemyShip.png
  -| player.png
  -| laserRed.png
-| index.html
-| app.js
-| package.json
```

Inicia su proyecto en la맊arpeta`juegoEspacial` escribiendo:

```
cd juegoEspacial
npm start
```

Lo anterior iniciar치 un servidor HTTP en la direcci칩n`http://localhost:5000`.ㅁbra un navegador e ingrese esa direcci칩n, en este momento deber칤a representar al h칠roe y a todos los enemigos, nada se mueve, todav칤a :).

### Agregar c칩digo

1. **Configure una representaci칩n rectangular de su objeto de juego, para manejar la colisi칩n.**

El siguiente c칩digo le permite obtener una representaci칩n rectangular de un archivo`GameObject`.Edite su clase GameObject para ampliarla:

    ```JavaScript
    rectFromGameObject() {
        return {
          top: this.y,
          left: this.x,
          bottom: this.y + this.height,
          right: this.x + this.width,
        };
      }
    ```
    
2. **Agregue c칩digo que verifique la colisi칩n**Esta ser치 una nueva funci칩n que prueba si dos rect치ngulos se cruzan:
    
    ```JavaScript
    function intersectRect(r1, r2) {
      return !(
        r2.left > r1.right ||
        r2.right < r1.left ||
        r2.top > r1.bottom ||
        r2.bottom < r1.top
      );
    }
    ```
    
3. **Agregar capacidad de disparo l치ser**
    1. **Agregar mensaje de evento clave**
    La tecla*de espacio*맋eber칤a crear un l치ser justo encima de la nave del h칠roe.ㅁgregue tres constantes en el objeto Messages:
        
        ```JavaScript
         KEY_EVENT_SPACE: "KEY_EVENT_SPACE",
         COLLISION_ENEMY_LASER: "COLLISION_ENEMY_LASER",
         COLLISION_ENEMY_HERO: "COLLISION_ENEMY_HERO",
        ```
        
    2. **Maneja la tecla de espacio**.Edite la`window.addEventListener`funci칩n keyup para manejar espacios:
        
        ```JavaScript
          } else if(evt.keyCode === 32) {
            eventEmitter.emit(Messages.KEY_EVENT_SPACE);
          }
        ```
        
    3. **A침adir oyentes**.Edite la`initGame()`funci칩n para asegurarse de que el h칠roe pueda disparar cuando presione la barra espaciadora:
        
        ```JavaScript
        eventEmitter.on(Messages.KEY_EVENT_SPACE, () => {
         if (hero.canFire()) {
           hero.fire();
         }
        ```
        
        y agrega una nueva`eventEmitter.on()`funci칩n para garantizar el comportamiento cuando un enemigo choca con un l치ser:
        
        ```JavaScript
        eventEmitter.on(Messages.COLLISION_ENEMY_LASER, (_, { first, second }) => {
          first.dead = true;
          second.dead = true;
        })
        ```
        
    4. **Mueva el objeto**, aseg칰rese de que el l치ser se mueva hacia la parte superior de la pantalla gradualmente.Crear치 una nueva clase de l치ser que se extienda`GameObject`, como lo ha hecho antes:
        
        ```JavaScript
          class Laser extends GameObject {
          constructor(x, y) {
            super(x,y);
            (this.width = 9), (this.height = 33);
            this.type = 'Laser';
            this.img = laserImg;
            let id = setInterval(() => {
              if (this.y > 0) {
                this.y -= 15;
              } else {
                this.dead = true;
                clearInterval(id);
              }
            }, 100)
          }
        }
        ```
        
    5. **Manejar colisiones**, implementar reglas de colisi칩n para el l치ser.ㅁgregue una`updateGameObjects()`funci칩n que pruebe los objetos que chocan en busca de aciertos.
        
        ```JavaScript
        function updateGameObjects() {
          const enemies = gameObjects.filter(go => go.type === 'Enemy');
          const lasers = gameObjects.filter((go) => go.type === "Laser");
        // el l치ser golpe칩 algo
          lasers.forEach((l) => {
            enemies.forEach((m) => {
              if (intersectRect(l.rectFromGameObject(), m.rectFromGameObject())) {
              eventEmitter.emit(Messages.COLLISION_ENEMY_LASER, {
                first: l,
                second: m,
              });
            }
           });
        });
        
          gameObjects = gameObjects.filter(go => !go.dead);
        }
        ```
        
        Aseg칰rate de agregar`updateGameObjects()`a tu bucle de juego en formato`window.onload`.
        
    6. **Implemente el enfriamiento**만n el l치ser, por lo que solo se puede disparar con cierta frecuencia.
        
        Finalmente, edite la clase Hero para que pueda enfriarse:
        
        ```JavaScript
        class Hero extends GameObject {
         constructor(x, y) {
           super(x, y);
           (this.width = 99), (this.height = 75);
           this.type = "Hero";
           this.speed = { x: 0, y: 0 };
           this.cooldown = 0;
         }
         fire() {
           gameObjects.push(new Laser(this.x + 45, this.y - 10));
           this.cooldown = 500;
        
           let id = setInterval(() => {
             if (this.cooldown > 0) {
               this.cooldown -= 100;
             } else {
               clearInterval(id);
             }
           }, 200);
         }
         canFire() {
           return this.cooldown === 0;
         }
        }
        ```
        

춰En este punto, tu juego tiene algunas funciones!Puedes navegar con las teclas de flecha, disparar un l치ser con la barra espaciadora y los enemigos desaparecen cuando los golpeas.먝멕ien hecho!


# Construyendo un juego espacial Parte 5: Puntuaci칩n y vidas

## Dibujar texto en la pantalla

Para poder mostrar la puntuaci칩n de un juego en la pantalla, deber치 saber c칩mo colocar texto en la pantalla.La respuesta est치 usando el맔칠todo `fillText()` en el objeto de canvas.Tambi칠n puedes controlar otros aspectos como qu칠 fuente usar, el color del texto e incluso su alineaci칩n (izquierda, derecha, centro).ㅁ continuaci칩n se muestra un c칩digo que dibuja un texto en la pantalla.

```Javascript
ctx.font = "30px Arial";
ctx.fillStyle = "red";
ctx.textAlign = "right";
ctx.fillText("show this on the screen", 0, 0);
```

九Lea m치s sobre[c칩mo agregar texto a canvas](https://developer.mozilla.org/docs/Web/API/Canvas_API/Tutorial/Drawing_text)맟 si칠ntase libre de hacer que el suyo se vea m치s elegante.

## La vida, como concepto de juego

El concepto de tener una vida en un juego es solo un n칰mero.En el contexto de un juego espacial, es com칰n asignar un conjunto de vidas que se restan una por una cuando tu nave sufre da침os.Es bueno si puedes mostrar una representaci칩n gr치fica de esto como minibarcos o corazones en lugar de un n칰mero.

## que construir

Agreguemos lo siguiente a su juego:

- **Puntuaci칩n del juego**
    
    : Por cada barco enemigo que se destruya, el h칠roe debe recibir algunos puntos, sugerimos 100 puntos por barco.La puntuaci칩n del juego debe mostrarse en la parte inferior izquierda.
    
- **Vida**
    
    : Tu barco tiene tres vidas.Pierdes una vida cada vez que un barco enemigo choca contigo.Una puntuaci칩n de vida debe mostrarse en la parte inferior derecha y estar hecha a partir del siguiente gr치fico
    
- [life](../JuegoEspacial/assets/life.png)
    
    
    

## Pasos recomendados

Localice los archivos que se han creado para usted en la맊arpeta `juegoEspacial`.Debe contener lo siguiente:

```bash
-| assets
  -| enemyShip.png
  -| player.png
  -| laserRed.png
-| index.html
-| app.js
-| package.json
```

Inicia su proyecto en la맊arpeta `juegoEspacial`escribiendo:

```bash
cd juegoEspacial
npm start
```

Lo anterior iniciar치 un servidor HTTP en la direcci칩n`http://localhost:5000`.ㅁbra un navegador e ingrese esa direcci칩n, en este momento deber칤a representar al h칠roe y a todos los enemigos, y cuando presiona las flechas izquierda y derecha, el h칠roe se mueve y puede derribar a los enemigos.

### Agregar c칩digo

1. **Copie los activos necesarios**맋e la맊arpeta`assets` a la맊arpeta `juegoEspacial`;마gregar치 un마ctivo `life.png`.ㅁgregue lifeImg a la funci칩n window.onload:
    
    ```javascript
    lifeImg = await loadTexture("assets/life.png");
    ```
    
2. Agregue el`lifeImg`a la lista de activos:
    
    ```javascript
    let heroImg,
    ...
    lifeImg,
    ...
    eventEmitter = new EventEmitter();
    ```
    
3. **A침adir variables**.ㅁgregue un c칩digo que represente su puntaje total (0) y las vidas restantes (3), muestre estos puntajes en una pantalla.


4. **Ampliar맓a funci칩n`updateGameObjects()`**.Extienda la`updateGameObjects()`funci칩n para manejar las colisiones enemigas:
    
    ```javascript
    enemies.forEach(enemy => {
        const heroRect = hero.rectFromGameObject();
        if (intersectRect(heroRect, enemy.rectFromGameObject())) {
          eventEmitter.emit(Messages.COLLISION_ENEMY_HERO, { enemy });
        }
      })
    ```
    
5. **Agregar`life`y`points`**.
    1. **Inicializar variables**.Debajo`this.cooldown = 0`de la맊lase `Hero`, establezca la vida y los puntos:
        
        ```javascript
        this.life = 3;
        this.points = 0;
        ```
        
    2. **Dibujar variables en pantalla**.Dibuje estos valores en la pantalla:
        
        ```javascript
        function drawLife() {
          // TODO, 35, 27
          const START_POS = canvas.width - 180;
          for(let i=0; i < hero.life; i++ ) {
            ctx.drawImage(
              lifeImg,
              START_POS + (45 * (i+1) ),
              canvas.height - 37);
          }
        }
        
        function drawPoints() {
          ctx.font = "30px Arial";
          ctx.fillStyle = "red";
          ctx.textAlign = "left";
          drawText("Points: " + hero.points, 10, canvas.height-20);
        }
        
        function drawText(message, x, y) {
          ctx.fillText(message, x, y);
        }
        ```
        
    3. **Agregue m칠todos a Game loop**.ㅁseg칰rese de agregar estas funciones a su funci칩n window.onload en`updateGameObjects()`:
        
        ```javascript
        drawPoints();
        drawLife();
        ```
        
6. **Implementar reglas de juego**.Implemente las siguientes reglas del juego:
    1. **Por cada colisi칩n de h칠roe y enemigo**, resta una vida.
        
        Extiende la맊lase `Hero` para hacer esta deducci칩n:
        
        ```javaScript
        decrementLife() {
          this.life--;
          if (this.life === 0) {
            this.dead = true;
          }
        }
        ```
        
    2. **Por cada l치ser que golpea a un enemigo**, aumenta la puntuaci칩n del juego en 100 puntos.
        
        Extiende la clase Hero para hacer este incremento:
        
        ```javascript
          incrementPoints() {
            this.points += 100;
          }
        ```
        
        Agregue estas funciones a sus emisores de eventos de colisi칩n:
        
        ```javascript
        eventEmitter.on(Messages.COLLISION_ENEMY_LASER, (_, { first, second }) => {
           first.dead = true;
           second.dead = true;
           hero.incrementPoints();
        })
        
        eventEmitter.on(Messages.COLLISION_ENEMY_HERO, (_, { enemy }) => {
           enemy.dead = true;
           hero.decrementLife();
        });
        ```
        

九Investigue un poco para descubrir otros juegos creados con JavaScript/Canvas.먝쮺u치les son sus rasgos comunes?

Al final de este trabajo, deber칤as ver las peque침as naves de 'vida' en la parte inferior derecha, los puntos en la parte inferior izquierda, y deber칤as ver que tu recuento de vidas disminuye a medida que chocas con los enemigos y tus puntos aumentan cuando disparas a los enemigos.먝멕ien hecho!Tu juego est치 casi completo.


