# Clase 16 - Desarrollando juegos avanzados con js

# Construir un juego espacial Parte 1: Introducción

En esta lección aprenderás a construir tu propio juego espacial. Si alguna vez has jugado al juego "Space Invaders", este juego tiene la misma idea: dirigir una nave espacial y disparar contra los monstruos que descienden desde arriba.

![video](../clase16_17/images/pewpew.gif)

En estas seis lecciones aprenderemos lo siguiente:

- Interactuar con el elemento Canvas para dibujar cosas en una pantalla
- Comprender el sistema de coordenadas cartesianas
- Aprenda el patrón Pub-Sub para crear una arquitectura de juego sólida que sea más fácil de mantener y ampliar
- Apalancamiento Asíncrono/Espera para cargar recursos del juego
- Controlar eventos de teclado

**Descripción general**

- Teoría
  - Introducción a la creación de juegos con JavaScript

- Práctica
  - Dibujar sobre lienzo
  - Mover elementos por la pantalla
  - Detección de colisiones
  - Manteniendo el marcador
  - Finalizar y reiniciar el juego.

## Introducción ##

### Herencia y composición en el desarrollo de juegos

En lecciones anteriores, no había mucha necesidad de preocuparse por la arquitectura de diseño de las aplicaciones que creó, ya que los proyectos tenían un alcance muy pequeño. Sin embargo, cuando sus aplicaciones crecen en tamaño y alcance, las decisiones arquitectónicas se vuelven una preocupación mayor. Hay dos enfoques principales para crear aplicaciones más grandes en JavaScript: *composición* o *herencia* . Ambos tienen pros y contras, pero vamos a explicarlos desde el contexto de un juego.

✅Uno de los libros de programación más famosos jamás escritos tiene que ver con [los patrones de diseño](https://en.wikipedia.org/wiki/Design_Patterns) .

En un juego tienes `game objects`que son objetos que existen en una pantalla. Esto significa que tienen una ubicación en un sistema de coordenadas cartesianas, caracterizado por tener una coordenada `x`y `y`. A medida que desarrolle un juego, notará que todos sus objetos de juego tienen una propiedad estándar, común para cada juego que crea, elementos que son:

- **basado en la ubicación**`xy`
  La mayoría de los elementos del juego, si no todos, se basan en la ubicación. Esto significa que tienen una ubicación, un `x` e `y`.
- **movible**
  Estos son objetos que pueden moverse a una nueva ubicación. Suele ser un héroe, un monstruo o un NPC (un personaje que no es jugador), pero no, por ejemplo, un objeto estático como un árbol.
- **autodestrucción**`deaddestroyed`
  Estos objetos solo existen durante un período de tiempo determinado antes de configurarse para su eliminación. Por lo general, esto se representa mediante un valor booleano `dead` o `destroyed` que indica al motor del juego que este objeto ya no debe representarse.
- **cool-down**
  `Cool-down` es una propiedad típica entre los objetos de vida corta. Un ejemplo típico es un texto o un efecto gráfico como una explosión que solo debería verse durante unos pocos milisegundos.

✅Piensa en un juego como Pac-Man. ¿Puedes identificar los cuatro tipos de objetos mencionados anteriormente en este juego?

### Expresando comportamiento

Todo lo que describimos anteriormente es el comportamiento que pueden tener los objetos del juego. Entonces, ¿cómo los codificamos? Podemos expresar este comportamiento como métodos asociados a clases u objetos.

**Clases**

La idea es usar `classes`en conjunto con `inheritance`para lograr agregar un cierto comportamiento a una clase.

✅La herencia es un concepto importante de entender. Obtén más información en [el artículo de MDN sobre la herencia](https://developer.mozilla.org/docs/Web/JavaScript/Inheritance_and_the_prototype_chain) .

Expresado a través de código, un objeto de juego normalmente puede tener este aspecto:

```javascript
//configurar la clase GameObject
class GameObject {
  constructor(x, y, type) {
    this.x = x;
    this.y = y;
    this.type = type;
  }
}

//esta clase ampliará las propiedades de clase inherentes del GameObject
class Movable extends GameObject {
  constructor(x,y, type) {
    super(x,y, type)
  }

//este objeto móvil se puede mover en la pantalla
  moveTo(x, y) {
    this.x = x;
    this.y = y;
  }
}

//esta es una clase específica que extiende la clase Movable, por lo que puede aprovechar todas las propiedades que hereda
class Hero extends Movable {
  constructor(x,y) {
    super(x,y, 'Hero')
  }
}

//esta clase, por otro lado, sólo hereda las propiedades de GameObject
class Tree extends GameObject {
  constructor(x,y) {
    super(x,y, 'Tree')
  }
}

//un héroe puede moverse..
const hero = new Hero();
hero.moveTo(5,5);

//pero un árbol no puede
const tree = new Tree();
```

✅Tómese unos minutos para volver a imaginar un héroe de Pac-Man (Inky, Pinky o Blinky, por ejemplo) y cómo se escribiría en JavaScript.

**Composición**

Una forma diferente de manejar la herencia de objetos es mediante el uso *de Composición* . Entonces, los objetos expresan su comportamiento así:

```javascript
//crear un objeto de gameObject
const gameObject = {
  x: 0,
  y: 0,
  type: ''
};

//...y un movimiento constante 
const movable = {
  moveTo(x, y) {
    this.x = x;
    this.y = y;
  }
}
//entonces la constante movableObject se compone de gameObject y constantes móviles
const movableObject = {...gameObject, ...movable};

//luego cree una función para crear un nuevo héroe que herede las propiedades de movableObject
function createHero(x, y) {
  return {
    ...movableObject,
    x,
    y,
    type: 'Hero'
  }
}
//... y un objeto estático que hereda sólo las propiedades de gameObject
function createStatic(x, y, type) {
  return {
    ...gameObject
    x,
    y,
    type
  }
}
//crea el héroe y muévelo
const hero = createHero(10,10);
hero.moveTo(5,5);
//and create a static tree which only stands around
const tree = createStatic(0,0, 'Tree');
```

**¿Qué patrón debo usar?**

Depende de ti qué patrón eliges. JavaScript admite ambos paradigmas.

Otro patrón común en el desarrollo de juegos aborda el problema de manejar la experiencia y el rendimiento del usuario del juego.

## Patrón de publicación/suscripción

✅Pub/Sub significa 'publicar-suscribir'

Este patrón aborda la idea de que las partes dispares de su aplicación no deberían conocerse entre sí. ¿Porqué es eso? Hace que sea mucho más fácil ver lo que sucede en general si se separan varias partes. También hace que sea más fácil cambiar repentinamente el comportamiento si es necesario. ¿Cómo logramos esto? Esto lo hacemos estableciendo algunos conceptos:

- **mensaje** 
  :un mensaje suele ser una cadena de texto acompañada de una carga útil opcional (un dato que aclara de qué se trata el mensaje). Un mensaje típico en un juego puede ser `KEY_PRESSED_ENTER`
  .
- **editor**
  : este elemento publica  un mensaje y lo envía a todos los suscriptores.
- **suscriptor**
  : este elemento escucha mensajes específicos y realiza alguna tarea como resultado de recibir este mensaje, como disparar un láser.

La implementación es bastante pequeña en tamaño pero es un patrón muy poderoso. Así es como se puede implementar:

```javascript
//configurar una clase EventEmitter que contenga oyentes
class EventEmitter {
  constructor() {
    this.listeners = {};
  }
//cuando se recibe un mensaje, deja que el oyente maneje su carga útil
  on(message, listener) {
    if (!this.listeners[message]) {
      this.listeners[message] = [];
    }
    this.listeners[message].push(listener);
  }
//cuando se envúa un mensaje, envíalo a un oyente con alguna carga útil
  emit(message, payload = null) {
    if (this.listeners[message]) {
      this.listeners[message].forEach(l => l(message, payload))
    }
  }
}
```

Para usar el código anterior, podemos crear una implementación muy pequeña:

```javascript
//configurar una estructura de mensaje
const Messages = {
  HERO_MOVE_LEFT: 'HERO_MOVE_LEFT'
};
//invoca el eventEmitter que configuraste anteriormente
const eventEmitter = new EventEmitter();
//establecer un héroe
const hero = createHero(0,0);
//informar al eventEmitter que esté atento a los mensajes relacionados con el héroe que se mueve hacia la izquierda y actúe en consecuencia.
eventEmitter.on(Messages.HERO_MOVE_LEFT, () => {
  hero.move(5,0);
});

//configure la ventana para escuchar el evento de tecla, específicamente si se presiona la flecha izquierda, emita un mensaje para mover al héroe hacia la izquierda
window.addEventListener('keyup', (evt) => {
  if (evt.key === 'ArrowLeft') {
    eventEmitter.emit(Messages.HERO_MOVE_LEFT)
  }
});
```

Arriba conectamos un evento de teclado `ArrowLeft`y enviamos el `HERO_MOVE_LEFT`mensaje. Escuchamos ese mensaje y lo movemos `hero`como resultado. El punto fuerte de este patrón es que el oyente del evento y el héroe no se conocen. Puede reasignar el `ArrowLeft`a la `A`clave. Además, sería posible hacer algo completamente diferente `ArrowLeft`haciendo algunas ediciones en la `on`función de eventEmitter:

```javascript
eventEmitter.on(Messages.HERO_MOVE_LEFT, () => {
  hero.move(5,0);
});
```

A medida que las cosas se vuelven más complicadas cuando tu juego crece, este patrón se mantiene igual en complejidad y tu código se mantiene limpio. Es muy recomendable adoptar este patrón.



# Construye un juego espacial, parte 2: dibuja héroes y monstruos en el lienzo

## Canva

Canva (lienzo) es un elemento HTML que por defecto no tiene contenido; es una pizarra en blanco. Necesitas agregarle dibujando sobre él.

✅Lea [más sobre la API de Canvas](https://developer.mozilla.org/docs/Web/API/Canvas_API) en MDN.

Así es como se declara normalmente, como parte del cuerpo de la página:

```HTML
<canvas id="myCanvas" width="200" height="100"></canvas>
```

Arriba estamos configurando `id`, `width`y `height`.

- `id`: configure esto para que pueda obtener una referencia cuando necesite interactuar con él.
    
- `width`: este es el ancho del elemento.
    
- `height`: esta es la altura del elemento.
    

## Dibujar geometría simple

El lienzo utiliza un sistema de coordenadas cartesianas para dibujar cosas. Por lo tanto, utiliza un eje x y un eje y para expresar dónde se encuentra algo. La ubicación `0,0`es la posición superior izquierda y la inferior derecha es lo que usted dijo que es el ANCHO y el ALTO del lienzo.

![Canvas](canvas_grid.png)


Para dibujar en el elemento del lienzo, deberá seguir los siguientes pasos:

1. **Obtenga una referencia** al elemento Canvas.
    
2. **Obtenga una referencia** sobre el elemento de contexto que se encuentra en el elemento de lienzo.
    
3. **Realice una operación de dibujo** utilizando el elemento de contexto.
    

El código para los pasos anteriores generalmente se ve así:

```Javascript
// Dibuja un rectángulo rojo
//1. Obtener la referencia de CANVAS
canvas = document.getElementById("myCanvas");

//2. Establezca el contexto en 2D para dibujar formas básicas
ctx = canvas.getContext("2d");

//3. Rellenalo con el color rojo
ctx.fillStyle = 'red';

//4. y dibuja un rectángulo con estos parámetros, configurando ubicación y tamaño
ctx.fillRect(0,0, 200, 200) // x,y,width, height
```

✅La API de Canvas se enfoca principalmente en formas 2D, pero también puede dibujar elementos 3D en un sitio web; para esto, puede usar la [API de WebGL](https://developer.mozilla.org/docs/Web/API/WebGL_API) .

Puede dibujar todo tipo de cosas con la API de Canvas como:

- **Formas geométricas** ya mostramos cómo dibujar un rectángulo, pero hay mucho más que puedes dibujar.
    
- **Texto** puede dibujar un texto con cualquier fuente y color que desee.
    
- **Imágenes**puede dibujar una imagen basada en un recurso de imagen como .jpg o .png, por ejemplo.
    

✅¡Intentalo! Sabes cómo dibujar un rectángulo, ¿puedes dibujar un círculo en una página? Eche un vistazo a algunos dibujos interesantes de Canvas en CodePen. He aquí un [ejemplo particularmente impresionante](https://codepen.io/dissimulate/pen/KrAwx) .

## Cargue y dibuje un recurso de imagen

Carga un activo de imagen creando un `Image`objeto y configurando su `src`propiedad. Luego, escucha el evento `load` para saber cuándo está listo para usarse. El código se ve así:

### Cargar activo

```javascript
const img = new Image();
img.src = 'path/to/my/image.png';
img.onload = () => {
  // Imagen cargada y lista para ser utilizada.
}
```

### Cargar patrón de activos

Se recomienda envolver lo anterior en una construcción como esta, para que sea más fácil de usar y solo intente manipularlo cuando esté completamente cargado:

```javascript
function loadAsset(path) {
  return new Promise((resolve) => {
    const img = new Image();
    img.src = path;
    img.onload = () => {
      // Imagen cargada y lista para ser utilizada.
      resolve(img);
    }
  })
}

// usar así

async function run() {
  const heroImg = await loadAsset('hero.png')
  const monsterImg = await loadAsset('monster.png')
}
```

Para dibujar activos del juego en una pantalla, su código se vería así:

```javascript
async function run() {
  const heroImg = await loadAsset('hero.png')
  const monsterImg = await loadAsset('monster.png')

  canvas = document.getElementById("myCanvas");
  ctx = canvas.getContext("2d");
  ctx.drawImage(heroImg, canvas.width/2,canvas.height/2);
  ctx.drawImage(monsterImg, 0,0);
}
```

## Ahora es el momento de comenzar a construir tu juego.

### que construir

Construirás una página web con un elemento Canvas. Debería mostrar una pantalla negra `1024*768`.Aqui tendrás dos imágenes:

- Nave héroe
    
    ![Nave héroe](../clase16_17_18/assets/player.png)
    
- 5*5 monstruo
    
    ![Nave Monstruo](../clase16_17_18/assets/enemyShip.png)
    

### Pasos recomendados para iniciar el desarrollo

Localice los archivos que se han creado para usted. Debe contener lo siguiente:

```bash
-| assets
  -| enemyShip.png
  -| player.png
-| index.html
-| app.js
-| package.json
```

Abra la copia de esta carpeta en Visual Studio Code. Debe tener una configuración de entorno de desarrollo local, preferiblemente con Visual Studio Code con NPM y Node instalados. Si no lo ha `npm`configurado en su computadora, [aquí le mostramos cómo hacerlo](https://www.npmjs.com/get-npm) .

Comience su proyecto navegando a la carpeta`clase16_17_18`carpeta:

```bash
cd clase16_17_18
npm start
```

Lo anterior iniciará un servidor HTTP en la dirección `http://localhost:5000`. Abre un navegador e ingresa esa dirección. Es una página en blanco en este momento, pero eso cambiará.

> Nota: para ver los cambios en su pantalla, actualice su navegador.
>

### Agregar código

Agregue el código necesario para `clase16_17_18/app.js`resolver lo siguiente

1. **Dibuja** un lienzo con fondo negro.
    
    > consejo: agregue en /app.js, configurando el elemento `ctx` para que sea negro y las coordenadas superior/izquierda estén en 0,0 y la altura y el ancho sean iguales a los de canva.
    > 
2. **Cargar** texturas
    
    > consejo: agregue las imágenes del jugador y del enemigo usando await loadTexturey pasando la ruta de la imagen. ¡Aún no los verás en la pantalla!
    > 
3. **Dibujar** héroe en el centro de la pantalla en la mitad inferior
    
    > consejo: use la drawImageAPI para dibujar hero Img en la pantalla, configurando canvas.width / 2 - 45y canvas.height - canvas.height / 4);
    > 
4. **Dibujar** 5*5 monstruos
    
    > consejo: ahora puedes descomentar el código para dibujar enemigos en la pantalla. A continuación, vaya a la createEnemiesfunción y constrúyala.
    > 
    
    Primero, configure algunas constantes:
    
    ```javascript
    const MONSTER_TOTAL = 5;
    const MONSTER_WIDTH = MONSTER_TOTAL * 98;
    const START_X = (canvas.width - MONSTER_WIDTH) / 2;
    const STOP_X = START_X + MONSTER_WIDTH;
    ```
    
    luego, crea un bucle para dibujar la matriz de monstruos en la pantalla:
    
    ```javascript
    for (let x = START_X; x < STOP_X; x += 98) {
        for (let y = 0; y < 50 * 5; y += 50) {
          ctx.drawImage(enemyImg, x, y);
        }
      }
    ```
    

## Resultado

El resultado final debería verse así:

![Ejemplo resultado primera parte](partI-solution.png)

# Construir un juego espacial Parte 3: agregar movimiento

¡Los juegos no son muy divertidos hasta que tienes extraterrestres corriendo en la pantalla! En este juego, haremos uso de dos tipos de movimientos:

- **Movimiento de teclado/ratón**
    
    : cuando el usuario interactúa con el teclado o el ratón para mover un objeto en la pantalla.
    
- **Movimiento inducido por el juego**
    
    : cuando el juego mueve un objeto con un cierto intervalo de tiempo.
    

Entonces, ¿cómo movemos las cosas en una pantalla? Se trata de coordenadas cartesianas: cambiamos la ubicación (x, y) del objeto y luego volvemos a dibujar la pantalla.

Por lo general, necesita los siguientes pasos para realizar *el movimiento* en una pantalla:

1. **Establecer una nueva ubicación**
    
    para un objeto; esto es necesario para percibir que el objeto se ha movido.
    
2. **Borrar la pantalla**
    
    , la pantalla debe limpiarse entre cada juego. Podemos despejarlo dibujando un rectángulo que rellenamos con un color de fondo.
    
3. **Vuelva a dibujar el objeto**
    
    en la nueva ubicación. Al hacer esto, finalmente logramos mover el objeto de un lugar a otro.
    

Así es como puede verse en el código:

```javascript
//establecer la ubicación del héroe
hero.x += 5;
// Limpia el rectángulo que alberga al héroe.
ctx.clearRect(0, 0, canvas.width, canvas.height);
// volver a dibujar el fondo y el héroe del juego
ctx.fillRect(0, 0, canvas.width, canvas.height)
ctx.fillStyle = "black";
ctx.drawImage(heroImg, hero.x, hero.y);
```

✅¿Puedes pensar en una razón por la que volver a dibujar a tu héroe muchos fotogramas por segundo podría generar costos de rendimiento? Lea acerca de [las alternativas a este patrón](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Optimizing_canvas) .

## Manejar eventos de teclado

Maneja eventos adjuntando eventos específicos al código. Los eventos del teclado se activan en toda la ventana, mientras que los eventos del mouse, como un, `click`se pueden conectar al hacer clic en un elemento específico. Usaremos eventos de teclado a lo largo de este proyecto.

Para manejar un evento, debe usar el método `addEventListener()` y proporcionarle dos parámetros de entrada. El primer parámetro es el nombre del evento, por ejemplo `keyup`. El segundo parámetro es la función que se debe invocar como resultado de que se produzca el evento.

Aquí hay un ejemplo:

```JavaScript
window.addEventListener('keyup', (evt) => {
  // `evt.key` = representación de cadena de la clave
  if (evt.key === 'ArrowUp') {
    // hacer algo
  }
})
```

Para eventos clave, hay dos propiedades en el evento que puede usar para ver qué tecla se presionó:

- `key`
    
    , esta es una representación de cadena de la tecla presionada, por ejemplo `ArrowUp`
    
- `keyCode`
    
    , esta es una representación numérica, por ejemplo 37, corresponde a `ArrowLeft`.
    

✅La manipulación de eventos clave es útil fuera del desarrollo de juegos. ¿Qué otros usos se te ocurren para esta técnica?

### Teclas especiales: una advertencia

Hay algunas teclas *especiales* que afectan a la ventana. Eso significa que si estás escuchando un `keyup`evento y usas estas teclas especiales para mover a tu héroe, también realizará el desplazamiento horizontal. Por esa razón, es posible que desee *desactivar* este comportamiento integrado del navegador a medida que desarrolla su juego. Necesitas un código como este:

```JavaScript
let onKeyDown = function (e) {
  console.log(e.keyCode);
  switch (e.keyCode) {
    case 37:
    case 39:
    case 38:
    case 40: // Teclas de flechas
    case 32: // Tecla espacio
      e.preventDefault();
      break; 
    default:
      break; // No bloquear otras claves
  }
};

window.addEventListener('keydown', onKeyDown);
```
📢 más info sobre el objeto window
- [window](https://developer.mozilla.org/es/docs/Web/API/Window)

El código anterior garantizará que las teclas de flecha y la tecla de espacio tengan su comportamiento *predeterminado* desactivado. El mecanismo *de apagado* ocurre cuando llamamos `e.preventDefault()`.

## Movimiento inducido por el juego

Podemos hacer que las cosas se muevan solas usando temporizadores como la función `setTimeout()`o `setInterval()`que actualiza la ubicación del objeto en cada marca o intervalo de tiempo. Esto es lo que puede parecer:

```JavaScript
let id = setInterval(() => {
  // Mueve al enemigo en el eje y
  enemy.y += 10;
})
```

## el bucle del juego

El bucle del juego es un concepto que es esencialmente una función que se invoca a intervalos regulares. Se llama bucle de juego porque todo lo que debería ser visible para el usuario se dibuja en el bucle. El bucle del juego hace uso de todos los objetos del juego que forman parte del juego, dibujándolos todos a menos que por alguna razón ya no deban ser parte del juego. Por ejemplo, si un objeto es un enemigo que fue golpeado por un láser y explota, ya no forma parte del ciclo actual del juego (aprenderás más sobre esto en lecciones posteriores).

Este es el aspecto típico de un bucle de juego, expresado en código:

```JavaScript
let gameLoopId = setInterval(() =>
  function gameLoop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    drawHero();
    drawEnemies();
    drawStaticObjects();
}, 200);
```

El bucle anterior se invoca cada `200`milisegundos para volver a dibujar el lienzo. Tienes la posibilidad de elegir el mejor intervalo que tenga sentido para tu juego.

## Continuando con el juego espacial

Tomará el código existente y lo ampliará. Comienza con el código que completaste durante la parte I o usa el código en la segunda parte.

- **Mover al héroe**
    
    : agregará código para asegurarse de que puede mover al héroe con las teclas de flecha.
    
- **Mover enemigos**
    
    : también deberá agregar código para asegurarse de que los enemigos se muevan de arriba a abajo a un ritmo determinado.
    

## Pasos recomendados

Localice los archivos que se han creado para usted . Debe contener lo siguiente:

```bash
-| assets
  -| enemyShip.png
  -| player.png
-| index.html
-| app.js
-| package.json
```

Inicia su proyecto en la carpeta escribiendo:

```bash
cd clase16_17_18
npm start
```

Lo anterior iniciará un servidor HTTP en la dirección `http://localhost:5000`. Abra un navegador e ingrese esa dirección, en este momento debería representar al héroe y a todos los enemigos; nada se mueve, ¡todavía!

### Agregar código

1. **Agregue objetos dedicados** para `hero`and `enemy`y `game object`, deben tener propiedades `x`y `y`. (Recordar la parte sobre Herencia o composición.
    
    *SUGERENCIA* `game object` debe ser el que tiene `x`y `y`la capacidad de dibujarse a sí mismo en un lienzo.
    
    > consejo: comience agregando una nueva clase GameObject con su constructor delineado como se muestra a continuación, y luego dibújelo en el lienzo:
    > 
    
    ```JavaScript
    class GameObject {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.dead = false;
        this.type = "";
        this.width = 0;
        this.height = 0;
        this.img = undefined;
      }
    
      draw(ctx) {
        ctx.drawImage(this.img, this.x, this.y, this.width, this.height);
      }
    }
    ```
    
    Ahora, extienda este GameObject para crear el Héroe y el Enemigo.
    
    ```JavaScript
    class Hero extends GameObject {
      constructor(x, y) {
        ...it needs an x, y, type, and speed
      }
    }
    ```
    
    ```JavaScript
    class Enemy extends GameObject {
      constructor(x, y) {
        super(x, y);
        (this.width = 98), (this.height = 50);
        this.type = "Enemy";
        let id = setInterval(() => {
          if (this.y < canvas.height - this.height) {
            this.y += 5;
          } else {
            console.log('Stopped at', this.y)
            clearInterval(id);
          }
        }, 300)
      }
    }
    ```
    
2. **Agregue controladores de eventos clave** para manejar la navegación clave (mover héroe arriba/abajo izquierda/derecha)
    
    *RECUERDE* que es un sistema cartesiano, arriba a la izquierda es `0,0`. También recuerde agregar código para detener *el comportamiento predeterminado*
    
    > consejo: cree su función onKeyDown y adjúntela a la ventana:
    > 
    
    ```JavaScript
     let onKeyDown = function (e) {
           console.log(e.keyCode);
             ...agregue el código de la lección anterior para detener
             default behavior
           }
     };
    
     window.addEventListener("keydown", onKeyDown);
    ```
    
    Verifique la consola de su navegador en este punto y observe cómo se registran las pulsaciones de teclas.
    
3. **Implemente** el patrón Pub/sub , esto mantendrá su código limpio mientras sigue las partes restantes.
    
    Para hacer esta última parte, puedes:
    
    1. **Agregue un detector de eventos** en la ventana:
        
        ```JavaScript
         window.addEventListener("keyup", (evt) => {
           if (evt.key === "ArrowUp") {
             eventEmitter.emit(Messages.KEY_EVENT_UP);
           } else if (evt.key === "ArrowDown") {
             eventEmitter.emit(Messages.KEY_EVENT_DOWN);
           } else if (evt.key === "ArrowLeft") {
             eventEmitter.emit(Messages.KEY_EVENT_LEFT);
           } else if (evt.key === "ArrowRight") {
             eventEmitter.emit(Messages.KEY_EVENT_RIGHT);
           }
         });
        ```
        
    2. **Crea una clase EventEmitter** para publicar y suscribirte a los mensajes:
        
        ```JavaScript
        class EventEmitter {
          constructor() {
            this.listeners = {};
          }
        
          on(message, listener) {
            if (!this.listeners[message]) {
              this.listeners[message] = [];
            }
            this.listeners[message].push(listener);
          }
        
          emit(message, payload = null) {
            if (this.listeners[message]) {
              this.listeners[message].forEach((l) => l(message, payload));
            }
          }
        }
        ```
        
    3. **Agregue constantes** y configure EventEmitter:
        
        ```JavaScript
        const Messages = {
          KEY_EVENT_UP: "KEY_EVENT_UP",
          KEY_EVENT_DOWN: "KEY_EVENT_DOWN",
          KEY_EVENT_LEFT: "KEY_EVENT_LEFT",
          KEY_EVENT_RIGHT: "KEY_EVENT_RIGHT",
        };
        
        let heroImg,
            enemyImg,
            laserImg,
            canvas, ctx,
            gameObjects = [],
            hero,
            eventEmitter = new EventEmitter();
        ```
        
    4. **Inicializar el juego**
    
    ```JavaScript
    function initGame() {
      gameObjects = [];
      createEnemies();
      createHero();
    
      eventEmitter.on(Messages.KEY_EVENT_UP, () => {
        hero.y -=5 ;
      })
    
      eventEmitter.on(Messages.KEY_EVENT_DOWN, () => {
        hero.y += 5;
      });
    
      eventEmitter.on(Messages.KEY_EVENT_LEFT, () => {
        hero.x -= 5;
      });
    
      eventEmitter.on(Messages.KEY_EVENT_RIGHT, () => {
        hero.x += 5;
      });
    }
    ```
    
4. **Configurar el bucle del juego**
    
    Refactorice la función window.onload para inicializar el juego y configurar un bucle de juego en un buen intervalo. También agregará un rayo láser:
    
    ```JavaScript
    window.onload = async () => {
      canvas = document.getElementById("canvas");
      ctx = canvas.getContext("2d");
      heroImg = await loadTexture("assets/player.png");
      enemyImg = await loadTexture("assets/enemyShip.png");
      laserImg = await loadTexture("assets/laserRed.png");
    
      initGame();
      let gameLoopId = setInterval(() => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        drawGameObjects(ctx);
      }, 100)
    
    };
    ```
    
5. **Agregue código** para mover enemigos en un cierto intervalo
    
    Refactorice la `createEnemies()`función para crear los enemigos e introdúzcalos en la nueva clase gameObjects:
    
    ```JavaScript
    function createEnemies() {
      const MONSTER_TOTAL = 5;
      const MONSTER_WIDTH = MONSTER_TOTAL * 98;
      const START_X = (canvas.width - MONSTER_WIDTH) / 2;
      const STOP_X = START_X + MONSTER_WIDTH;
    
      for (let x = START_X; x < STOP_X; x += 98) {
        for (let y = 0; y < 50 * 5; y += 50) {
          const enemy = new Enemy(x, y);
          enemy.img = enemyImg;
          gameObjects.push(enemy);
        }
      }
    }
    ```
    
    y agregue una `createHero()`función para hacer un proceso similar para el héroe.
    
    ```JavaScript
    function createHero() {
      hero = new Hero(
        canvas.width / 2 - 45,
        canvas.height - canvas.height / 4
      );
      hero.img = heroImg;
      gameObjects.push(hero);
    }
    ```
    
    y finalmente, agregue una `drawGameObjects()`función para comenzar el dibujo:
    
    ```JavaScript
    function drawGameObjects(ctx) {
      gameObjects.forEach(go => go.draw(ctx));
    }
    ```
    
    ## ¡Tus enemigos deberían comenzar a avanzar en tu nave espacial heroica! 🚀🚀

  # Construir un juego espacial Parte 4: agregar un láser y detectar colisiones

¡En esta lección aprenderá a disparar láseres con JavaScript! Agregaremos dos cosas a nuestro juego:

- **Un láser**
    
    : este láser se dispara desde la nave de tus héroes y verticalmente hacia arriba.
    
- **Detección de colisión***disparar*
    
    , como parte de la implementación de la capacidad de
    
    , también agregaremos algunas reglas de juego agradables:
    
    - **El láser golpea al enemigo**
        
        : el enemigo muere si es golpeado por un láser.
        
    - **El láser golpea la pantalla superior**
        
        : un láser se destruye si golpea la parte superior de la pantalla
        
    - **Colisión de héroe y enemigo**
        
        : un enemigo y el héroe se destruyen si se golpean entre sí.
        
    - **El enemigo golpea la parte inferior de la pantalla**
        
        : un enemigo y un héroe son destruidos si el enemigo golpea la parte inferior de la pantalla.
        

En resumen, tú, *el héroe* , debes golpear a todos los enemigos con un láser antes de que logren moverse hacia la parte inferior de la pantalla.

✅Investigue un poco sobre el primer juego de computadora jamás escrito. ¿Cuál era su funcionalidad?

## Detección de colisiones

¿Cómo hacemos la detección de colisiones? Necesitamos pensar en los objetos de nuestro juego como rectángulos que se mueven. ¿Por qué es así te preguntarás? Bueno, la imagen que se usa para dibujar un objeto de juego es un rectángulo: tiene `x`, y `y` `width` `height`

Si dos rectángulos, es decir, un héroe y un enemigo *se cruzan* , tienes una colisión. Lo que debería suceder entonces depende de las reglas del juego. Por lo tanto, para implementar la detección de colisiones, necesita lo siguiente:

1. Una forma de obtener una representación rectangular de un objeto del juego, algo como esto:
    
    ```JavaScript
    rectFromGameObject() {
      return {
        top: this.y,
        left: this.x,
        bottom: this.y + this.height,
        right: this.x + this.width
      }
    }
    ```
    
2. Una función de comparación, esta función puede verse así:
    
    ```Javascript
    function intersectRect(r1, r2) {
      return !(r2.left > r1.right ||
        r2.right < r1.left ||
        r2.top > r1.bottom ||
        r2.bottom < r1.top);
    }
    ```
    

## ¿Cómo destruimos las cosas?

Para destruir cosas en un juego, debe informar al juego que ya no debe pintar este elemento en el ciclo del juego que se activa en un intervalo determinado. Una forma de hacer esto es marcar un objeto del juego como *muerto* cuando sucede algo, así:

```JavaScript
// ocurrió la colisión
enemy.dead = true
```

Luego, puede proceder a clasificar los objetos *muertos* antes de volver a pintar la pantalla, así:

```JavaScript
gameObjects = gameObject.filter(go => !go.dead);
```

## ¿Cómo disparamos un láser?

Disparar un láser se traduce en responder a un evento clave y crear un objeto que se mueve en una dirección determinada. Por lo tanto, debemos llevar a cabo los siguientes pasos:

1. **Crea un objeto láser**
    
    : desde la parte superior de la nave de nuestro héroe, que al crearse comienza a moverse hacia arriba, hacia la parte superior de la pantalla.
    
2. **Adjuntar código a un evento clave**
    
    : debemos elegir una tecla en el teclado que represente al jugador disparando el láser.
    
3. **Crea un objeto de juego que parece un láser**
    
    cuando se presiona la tecla.
    

## Enfriamiento en nuestro láser

El láser debe dispararse cada vez que presiona una tecla, como *espacio* , por ejemplo. Para evitar que el juego produzca demasiados láseres en poco tiempo, debemos solucionar este problema. La solución es implementar un llamado *enfriamiento* , un temporizador, que garantiza que un láser solo se pueda disparar con cierta frecuencia. Puedes implementar eso de la siguiente manera:

```JavaScript
class Cooldown {
  constructor(time) {
    this.cool = false;
    setTimeout(() => {
      this.cool = true;
    }, time)
  }
}

class Weapon {
  constructor {
  }
  fire() {
    if (!this.cooldown || this.cooldown.cool) {
      // Producir un láser
      this.cooldown = new Cooldown(500);
    } else {
      // no hagas nada, todavía no se ha enfriado.
    }
  }
}
```

✅Consulte la lección 1 de la serie de juegos espaciales para recordar los *tiempos de reutilización* .

## que construir

Tomará el código existente (que debería haber limpiado y refactorizado) de la lección anterior y lo ampliará. Empiece con el código de la Parte II o utilice el código de la Parte III

> consejo: el láser con el que trabajará ya está en su carpeta de activos y su código hace referencia a él
> 

- **Agregue detección de colisión**
    
    , cuando un láser colisiona con algo, se deben aplicar las siguientes reglas:
    
    1. **El láser golpea al enemigo**
        
        : el enemigo muere si es golpeado por un láser.
        
    2. **Laser hits top screen**
        
        : Un láser se destruye si golpea la parte superior de nuestra pantalla
        
    3. **Colisión de héroe y enemigo**
        
        : un enemigo y el héroe se destruyen si se golpean entre sí
        
    4. **El enemigo golpea la parte inferior de la pantalla**
        
        : un enemigo y un héroe se destruyen si el enemigo golpea la parte inferior de la pantalla.
        

## Pasos recomendados

Localice los archivos que se han creado para usted. Debe contener lo siguiente:

```bash
-| assets
  -| enemyShip.png
  -| player.png
  -| laserRed.png
-| index.html
-| app.js
-| package.json
```

Inicia su proyecto en la carpeta`juegoEspacial` escribiendo:

```
cd juegoEspacial
npm start
```

Lo anterior iniciará un servidor HTTP en la dirección `http://localhost:5000`. Abra un navegador e ingrese esa dirección, en este momento debería representar al héroe y a todos los enemigos, nada se mueve, todavía :).

### Agregar código

1. **Configure una representación rectangular de su objeto de juego, para manejar la colisión.** 

El siguiente código le permite obtener una representación rectangular de un archivo `GameObject`. Edite su clase GameObject para ampliarla:

    ```JavaScript
    rectFromGameObject() {
        return {
          top: this.y,
          left: this.x,
          bottom: this.y + this.height,
          right: this.x + this.width,
        };
      }
    ```
    
2. **Agregue código que verifique la colisión** Esta será una nueva función que prueba si dos rectángulos se cruzan:
    
    ```JavaScript
    function intersectRect(r1, r2) {
      return !(
        r2.left > r1.right ||
        r2.right < r1.left ||
        r2.top > r1.bottom ||
        r2.bottom < r1.top
      );
    }
    ```
    
3. **Agregar capacidad de disparo láser**
    1. **Agregar mensaje de evento clave** 
    La tecla *de espacio* debería crear un láser justo encima de la nave del héroe. Agregue tres constantes en el objeto Messages:
        
        ```JavaScript
         KEY_EVENT_SPACE: "KEY_EVENT_SPACE",
         COLLISION_ENEMY_LASER: "COLLISION_ENEMY_LASER",
         COLLISION_ENEMY_HERO: "COLLISION_ENEMY_HERO",
        ```
        
    2. **Maneja la tecla de espacio** . Edite la `window.addEventListener`función keyup para manejar espacios:
        
        ```JavaScript
          } else if(evt.keyCode === 32) {
            eventEmitter.emit(Messages.KEY_EVENT_SPACE);
          }
        ```
        
    3. **Añadir oyentes** . Edite la `initGame()`función para asegurarse de que el héroe pueda disparar cuando presione la barra espaciadora:
        
        ```JavaScript
        eventEmitter.on(Messages.KEY_EVENT_SPACE, () => {
         if (hero.canFire()) {
           hero.fire();
         }
        ```
        
        y agrega una nueva `eventEmitter.on()`función para garantizar el comportamiento cuando un enemigo choca con un láser:
        
        ```JavaScript
        eventEmitter.on(Messages.COLLISION_ENEMY_LASER, (_, { first, second }) => {
          first.dead = true;
          second.dead = true;
        })
        ```
        
    4. **Mueva el objeto** , asegúrese de que el láser se mueva hacia la parte superior de la pantalla gradualmente. Creará una nueva clase de láser que se extienda `GameObject`, como lo ha hecho antes:
        
        ```JavaScript
          class Laser extends GameObject {
          constructor(x, y) {
            super(x,y);
            (this.width = 9), (this.height = 33);
            this.type = 'Laser';
            this.img = laserImg;
            let id = setInterval(() => {
              if (this.y > 0) {
                this.y -= 15;
              } else {
                this.dead = true;
                clearInterval(id);
              }
            }, 100)
          }
        }
        ```
        
    5. **Manejar colisiones** , implementar reglas de colisión para el láser. Agregue una `updateGameObjects()`función que pruebe los objetos que chocan en busca de aciertos.
        
        ```JavaScript
        function updateGameObjects() {
          const enemies = gameObjects.filter(go => go.type === 'Enemy');
          const lasers = gameObjects.filter((go) => go.type === "Laser");
        // el láser golpeó algo
          lasers.forEach((l) => {
            enemies.forEach((m) => {
              if (intersectRect(l.rectFromGameObject(), m.rectFromGameObject())) {
              eventEmitter.emit(Messages.COLLISION_ENEMY_LASER, {
                first: l,
                second: m,
              });
            }
           });
        });
        
          gameObjects = gameObjects.filter(go => !go.dead);
        }
        ```
        
        Asegúrate de agregar `updateGameObjects()`a tu bucle de juego en formato `window.onload`.
        
    6. **Implemente el enfriamiento** en el láser, por lo que solo se puede disparar con cierta frecuencia.
        
        Finalmente, edite la clase Hero para que pueda enfriarse:
        
        ```JavaScript
        class Hero extends GameObject {
         constructor(x, y) {
           super(x, y);
           (this.width = 99), (this.height = 75);
           this.type = "Hero";
           this.speed = { x: 0, y: 0 };
           this.cooldown = 0;
         }
         fire() {
           gameObjects.push(new Laser(this.x + 45, this.y - 10));
           this.cooldown = 500;
        
           let id = setInterval(() => {
             if (this.cooldown > 0) {
               this.cooldown -= 100;
             } else {
               clearInterval(id);
             }
           }, 200);
         }
         canFire() {
           return this.cooldown === 0;
         }
        }
        ```
        

¡En este punto, tu juego tiene algunas funciones! Puedes navegar con las teclas de flecha, disparar un láser con la barra espaciadora y los enemigos desaparecen cuando los golpeas. ¡Bien hecho!


# Construyendo un juego espacial Parte 5: Puntuación y vidas

## Dibujar texto en la pantalla

Para poder mostrar la puntuación de un juego en la pantalla, deberá saber cómo colocar texto en la pantalla. La respuesta está usando el método `fillText()` en el objeto de canvas. También puedes controlar otros aspectos como qué fuente usar, el color del texto e incluso su alineación (izquierda, derecha, centro). A continuación se muestra un código que dibuja un texto en la pantalla.

```Javascript
ctx.font = "30px Arial";
ctx.fillStyle = "red";
ctx.textAlign = "right";
ctx.fillText("show this on the screen", 0, 0);
```

✅Lea más sobre [cómo agregar texto a canvas](https://developer.mozilla.org/docs/Web/API/Canvas_API/Tutorial/Drawing_text) y siéntase libre de hacer que el suyo se vea más elegante.

## La vida, como concepto de juego

El concepto de tener una vida en un juego es solo un número. En el contexto de un juego espacial, es común asignar un conjunto de vidas que se restan una por una cuando tu nave sufre daños. Es bueno si puedes mostrar una representación gráfica de esto como minibarcos o corazones en lugar de un número.

## que construir

Agreguemos lo siguiente a su juego:

- **Puntuación del juego**
    
    : Por cada barco enemigo que se destruya, el héroe debe recibir algunos puntos, sugerimos 100 puntos por barco. La puntuación del juego debe mostrarse en la parte inferior izquierda.
    
- **Vida**
    
    : Tu barco tiene tres vidas. Pierdes una vida cada vez que un barco enemigo choca contigo. Una puntuación de vida debe mostrarse en la parte inferior derecha y estar hecha a partir del siguiente gráfico
    
- [life](../JuegoEspacial/assets/life.png)
    
    
    

## Pasos recomendados

Localice los archivos que se han creado para usted en la carpeta `juegoEspacial`. Debe contener lo siguiente:

```bash
-| assets
  -| enemyShip.png
  -| player.png
  -| laserRed.png
-| index.html
-| app.js
-| package.json
```

Inicia su proyecto en la carpeta `juegoEspacial`escribiendo:

```bash
cd juegoEspacial
npm start
```

Lo anterior iniciará un servidor HTTP en la dirección `http://localhost:5000`. Abra un navegador e ingrese esa dirección, en este momento debería representar al héroe y a todos los enemigos, y cuando presiona las flechas izquierda y derecha, el héroe se mueve y puede derribar a los enemigos.

### Agregar código

1. **Copie los activos necesarios** de la carpeta`assets` a la carpeta `juegoEspacial`; agregará un activo `life.png`. Agregue lifeImg a la función window.onload:
    
    ```javascript
    lifeImg = await loadTexture("assets/life.png");
    ```
    
2. Agregue el `lifeImg`a la lista de activos:
    
    ```javascript
    let heroImg,
    ...
    lifeImg,
    ...
    eventEmitter = new EventEmitter();
    ```
    
3. **Añadir variables** . Agregue un código que represente su puntaje total (0) y las vidas restantes (3), muestre estos puntajes en una pantalla.


4. **Ampliar la función`updateGameObjects()`** . Extienda la `updateGameObjects()`función para manejar las colisiones enemigas:
    
    ```javascript
    enemies.forEach(enemy => {
        const heroRect = hero.rectFromGameObject();
        if (intersectRect(heroRect, enemy.rectFromGameObject())) {
          eventEmitter.emit(Messages.COLLISION_ENEMY_HERO, { enemy });
        }
      })
    ```
    
5. **Agregar `life`y`points`** .
    1. **Inicializar variables** . Debajo `this.cooldown = 0`de la clase `Hero`, establezca la vida y los puntos:
        
        ```javascript
        this.life = 3;
        this.points = 0;
        ```
        
    2. **Dibujar variables en pantalla** . Dibuje estos valores en la pantalla:
        
        ```javascript
        function drawLife() {
          // TODO, 35, 27
          const START_POS = canvas.width - 180;
          for(let i=0; i < hero.life; i++ ) {
            ctx.drawImage(
              lifeImg,
              START_POS + (45 * (i+1) ),
              canvas.height - 37);
          }
        }
        
        function drawPoints() {
          ctx.font = "30px Arial";
          ctx.fillStyle = "red";
          ctx.textAlign = "left";
          drawText("Points: " + hero.points, 10, canvas.height-20);
        }
        
        function drawText(message, x, y) {
          ctx.fillText(message, x, y);
        }
        ```
        
    3. **Agregue métodos a Game loop** . Asegúrese de agregar estas funciones a su función window.onload en `updateGameObjects()`:
        
        ```javascript
        drawPoints();
        drawLife();
        ```
        
6. **Implementar reglas de juego** . Implemente las siguientes reglas del juego:
    1. **Por cada colisión de héroe y enemigo** , resta una vida.
        
        Extiende la clase `Hero` para hacer esta deducción:
        
        ```javaScript
        decrementLife() {
          this.life--;
          if (this.life === 0) {
            this.dead = true;
          }
        }
        ```
        
    2. **Por cada láser que golpea a un enemigo** , aumenta la puntuación del juego en 100 puntos.
        
        Extiende la clase Hero para hacer este incremento:
        
        ```javascript
          incrementPoints() {
            this.points += 100;
          }
        ```
        
        Agregue estas funciones a sus emisores de eventos de colisión:
        
        ```javascript
        eventEmitter.on(Messages.COLLISION_ENEMY_LASER, (_, { first, second }) => {
           first.dead = true;
           second.dead = true;
           hero.incrementPoints();
        })
        
        eventEmitter.on(Messages.COLLISION_ENEMY_HERO, (_, { enemy }) => {
           enemy.dead = true;
           hero.decrementLife();
        });
        ```
        

✅Investigue un poco para descubrir otros juegos creados con JavaScript/Canvas. ¿Cuáles son sus rasgos comunes?

Al final de este trabajo, deberías ver las pequeñas naves de 'vida' en la parte inferior derecha, los puntos en la parte inferior izquierda, y deberías ver que tu recuento de vidas disminuye a medida que chocas con los enemigos y tus puntos aumentan cuando disparas a los enemigos. ¡Bien hecho! Tu juego está casi completo.


